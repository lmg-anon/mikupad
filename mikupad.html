<!doctype html>
<meta charset="utf-8">
<!-- mikupad by Anon
  --
  -- To the extent possible under law, the person who associated CC0 with
  -- mikupad has waived all copyright and related or neighboring rights
  -- to mikupad.
  --
  -- You should have received a copy of the CC0 legalcode along with this
  -- work.  If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.
  -->
<title>mikupad</title>
<script type="importmap">
{
	"imports": {
		"react": "https://esm.sh/react@18",
		"react-dom/client": "https://esm.sh/react-dom@18/client?external=react",
		"htm/react": "https://esm.sh/htm@3/react?external=react&react=18",
		"event-iterator": "https://esm.sh/event-iterator@2.0.0"
	}
}
</script>
<style>

html {
	--color-miku: #009bb3;
	--color-base-0: oklch(0.20 0.02 60);
	--color-base-10: color-mix(in oklch, var(--color-base-100) 10%, var(--color-base-0));
	--color-base-20: color-mix(in oklch, var(--color-base-100) 20%, var(--color-base-0));
	--color-base-30: color-mix(in oklch, var(--color-base-100) 30%, var(--color-base-0));
	--color-base-40: color-mix(in oklch, var(--color-base-100) 40%, var(--color-base-0));
	--color-base-50: color-mix(in oklch, var(--color-base-100) 50%, var(--color-base-0));
	--color-base-60: color-mix(in oklch, var(--color-base-100) 60%, var(--color-base-0));
	--color-base-70: color-mix(in oklch, var(--color-base-100) 70%, var(--color-base-0));
	--color-base-80: color-mix(in oklch, var(--color-base-100) 80%, var(--color-base-0));
	--color-base-90: color-mix(in oklch, var(--color-base-100) 90%, var(--color-base-0));
	--color-base-100: oklch(0.95 0.04 70);
	--color-dark: var(--color-base-0);
	--color-light: var(--color-base-100);

	font-family: serif;
	font-size: 16px;
	min-height: 100%;
	display: flex;
	flex-direction: column;

	accent-color: var(--color-base-30);
	background: var(--color-base-20);
	color: var(--color-base-0);
}

html.dark-mode {
	--color-base-0: oklch(0.95 0.04 30);
	--color-base-10: color-mix(in oklch, var(--color-base-100) 10%, var(--color-base-0));
	--color-base-20: color-mix(in oklch, var(--color-base-100) 80%, var(--color-base-0));
	--color-base-30: color-mix(in oklch, var(--color-base-100) 70%, var(--color-base-0));
	--color-base-40: color-mix(in oklch, var(--color-base-100) 60%, var(--color-base-0));
	--color-base-50: color-mix(in oklch, var(--color-base-100) 50%, var(--color-base-0));
	--color-base-60: color-mix(in oklch, var(--color-base-100) 40%, var(--color-base-0));
	--color-base-70: color-mix(in oklch, var(--color-base-100) 30%, var(--color-base-0));
	--color-base-80: color-mix(in oklch, var(--color-base-100) 20%, var(--color-base-0));
	--color-base-90: color-mix(in oklch, var(--color-base-100) 10%, var(--color-base-0));
	--color-base-100: oklch(0.20 0.02 30);
	--color-dark: var(--color-base-100);
	--color-light: var(--color-base-0);

	color-scheme: dark;
}

body {
	margin: 0;
	display: flex;
	flex: auto;
	flex-direction: row;
}

#prompt-container {
	position: relative;
	font-size: 1.125rem;
	max-width: 36em;
	margin-right: auto;
	margin-left: auto;
	flex: 1;
	display: flex;
	flex-direction: column;
}

#prompt-area, #prompt-overlay {
	flex: 1;
	border: none;
	outline: none;
	resize: none;
	background: var(--color-base-100);
	color: var(--color-base-10);
	padding: 2em 3em;
	margin: 0;
	scrollbar-gutter: stable;
	font: inherit;
}

#prompt-overlay {
	white-space: pre-wrap;
	position: absolute;
	left: 0;
	top: 0;
	right: 0;
	bottom: 0;
	background: transparent;
	color: transparent;
	pointer-events: none;
	overflow: auto;
}

#prompt-container:hover #prompt-overlay > .machine {
	background: color-mix(in srgb, var(--color-miku) 10%, transparent);
}
#prompt-container #prompt-overlay > .machine.erase {
	background: color-mix(in srgb, #FF0000 10%, transparent);
}
#prompt-container #prompt-overlay > .machine.current {
	border-radius: 3px;
	outline: 1px solid var(--color-base-50);
	outline-offset: 1px;
}

#probs {
	position: absolute;
	background: var(--color-base-30);
	top: var(--probs-top);
	left: var(--probs-left);
	display: flex;
	transform: translate(-50%, -100%);
	border-radius: 5px;
	box-shadow: 0 1px 1px 1px #00000033;
	/*transition: top 0.2s, left 0.2s;*/
}
#probs > button {
	cursor: pointer;
	background: transparent;
	color: var(--color-light);
	border-radius: 0;
	padding: 2px 3px;
	display: flex;
	flex-direction: column;
	flex: none;
	font-size: 0.875rem;
}
#probs > button:first-child {
	border-radius: 5px 0 0 5px;
	padding-left: 6px;
}
#probs > button:last-child {
	border-radius: 0 5px 5px 0;
	padding-right: 6px;
}
#probs > button:hover {
	background: var(--color-base-40);
}
#probs > button:active {
	background: var(--color-base-50);
}
#probs > button > .prob {
	font-size: 0.75rem;
}

#sidebar {
	width: 250px;
	background: var(--color-base-50);
	color: var(--color-light);
	padding: 4px 8px;
	display: flex;
	flex-direction: column;
	gap: 4px;
	overflow: auto;
}

.hbox {
	flex: none;
	display: grid;
	grid: auto / auto-flow minmax(min-content, 1fr);
	gap: 8px;
}
.vbox {
	flex: none;
	display: grid;
	grid: auto / minmax(min-content, 1fr) auto-flow;
	grid-template-rows: 0fr 0fr 0fr 0fr;
	gap: 4px;
}

.InputBox, .SelectBox {
	display: flex;
	flex-direction: column;
	font-size: 0.75rem;
	padding: 0 8px;
}
.InputBox > input, .SelectBox > select {
	appearance: none;
	border: none;
	outline: none;
	width: 100%;
	box-sizing: content-box;
	font: inherit;
	font-size: 1rem;
	padding: 4px 8px;
	margin: 0 -8px;
	border-radius: 2px;
	color: inherit;
	background: var(--color-base-30);
	flex: none;
}
.InputBox > input:read-only {
	background: var(--color-base-60);
}
.InputBox > input:focus-visible {
	outline: 1px solid var(--color-base-0);
}
.SelectBox > select:disabled {
	background: var(--color-base-60);
}

.Checkbox {
	margin: 0 5px 0 0;
	vertical-align: middle;
}

.InputBox > input.mixed-content {
	outline: 1px solid yellow;
}

.tooltip {
	position: relative;
}
.tooltip .tooltiptext {
	pointer-events: none;
	width: 95%;
	background-color: #000000AA;
	color: var(--color-light);
	text-align: center;
	padding: 5px 4px;
	margin: 0 -8px;
	border-radius: 6px;
	opacity: 0;
	transition: opacity 0.3s;

	position: absolute;
	z-index: 1;
	transform: translate(0, -75%);
}
.tooltip:hover .tooltiptext {
    opacity: 1;
}

.error-text {
	width: max-content;
	text-align: center;
	background: #4E3534;
	border-radius: 4px;
	color: #FF8080;
	margin-left: auto;
	margin-right: auto;
	padding: 2px 10px;
}

button {
	appearance: none;
	border: none;
	outline: none;
	font: inherit;
	padding: 4px 8px;
	color: inherit;
	background: var(--color-base-30);
	border-radius: 2px;
}
button:hover {
	background: var(--color-base-40);
}
button:active {
	background: var(--color-base-50);
}
button:disabled {
	background: var(--color-base-60);
}
button:focus-visible {
	outline: 1px solid var(--color-base-0);
}
button.processing {
	outline: 1px solid rgba(255, 255, 255, 0.5);
	animation: .5s ease-out infinite alternate processing;
}
@keyframes processing {
	from { outline-width: 0px; }
	to { outline-width: 4px; }
}
button.completing {
	outline: 1px solid limegreen;
	animation: .5s ease-out infinite alternate completing;
}
@keyframes completing {
	from { outline-width: 0px; }
	to { outline-width: 4px; }
}

.buttons {
	display: flex;
	gap: 8px;
	justify-content: center;
}
.buttons .shorts {
	line-height: 0;
}
.buttons .shorts > button {
	height: 100%;
}

.collapsible-group {
	border: none;
	outline: none;
}

.collapsible-header {
	user-select: none;
	cursor: pointer;
	display: flex;
	align-items: center;
	padding: 4px 8px;
	color: inherit;
	background-color: var(--color-base-30);
	border-radius: 2px;
}
.collapsible-header svg {
	margin-right: 5px;
}

.collapsible-content {
	transform: scaleY(0);
	transition: transform 0.15s ease-in-out 0s, max-height 0.15s ease-in-out 0s;
	transform-origin: center top;
	display: flex;
	flex-direction: column;
	gap: 4px;
}
.collapsible-content.expanded {
	transform: scaleY(1);
	margin-top: 4px;
}

.Sessions {
	display: flex;
	flex: auto;
	flex-direction: row;
	gap: 4px;
}
.Sessions > ul {
	list-style-type: none;
	margin: 0;
	padding: 0;
	max-height: 200px;
	overflow-y: auto;
	width: 100%;
	background: var(--color-base-40);
}
.Sessions.disabled > ul {
	background: var(--color-base-50);
	pointer-events: auto;
}

.Sessions > ul > li {
	display: flex;
	align-items: center;
}
.Sessions.disabled > ul > li {
	pointer-events: none;
}

.Session {
	width: 100%;
	padding: 0.5rem;
	padding-left: 0.8rem;
	cursor: pointer;
	display: flex;
	word-break: break-word;
	user-select: none;
}
.Session:hover {
	background-color: var(--color-base-60);
}
.Session.selected {
	background-color: var(--color-base-30);
}

.Session > button {
	margin-left: 4px;
	padding: 0;
	background: none;
	border: none;
	cursor: pointer;
	outline: none;
	line-height: 0;
	opacity: 0.5;
}
.Session > button:hover {
	opacity: 1;
}

.Session > input {
	padding: 0;
	appearance: none;
	border: none;
	outline: 1px solid var(--color-light);
	background-color: var(--color-base-40);
	font: inherit;
	color: inherit;
	width: 80%;
	margin-right: 5%;
}

.flex-separator {
	margin-left: auto;
}

</style>
<script type="module">

import { useEffect, useLayoutEffect, useMemo, useRef, useState } from 'react';
import { createRoot } from 'react-dom/client';
import { html } from 'htm/react';
import { EventIterator } from 'event-iterator';

// Polyfill for piece of shit Chromium
if (!(Symbol.asyncIterator in ReadableStream.prototype)) {
	ReadableStream.prototype[Symbol.asyncIterator] = async function* () {
		const reader = this.getReader();
		try {
			for (;;) {
				const { done, value } = await reader.read();
				if (done)
					return;
				yield value;
			}
		} finally {
			reader.releaseLock();
		}
	};
}

export async function getTokenCount({ endpoint, endpointAPI, signal, ...options }) {
	switch (endpointAPI) {
		case 0: // llama.cpp
			return await llamaCppTokenCount({ endpoint, signal, ...options });
		case 1: // oobabooga
			return await oobaTokenCount({ endpoint, signal, ...options });
		case 2: // koboldcpp
			return await koboldCppTokenCount({ endpoint, signal, ...options });
		case 3: // openai // TODO: Fix this for official OpenAI?
			return await openaiOobaTokenCount({ endpoint, signal, ...options });
	}
}

export async function getModels({ endpoint, endpointAPI, endpointAPIKey, signal, ...options }) {
	switch (endpointAPI) {
		case 3: // openai
			return await openaiModels({ endpoint, endpointAPIKey, signal, ...options });
		default:
			return [];
	}
}

export async function* completion({ endpoint, endpointAPI, endpointAPIKey, signal, ...options }) {
	switch (endpointAPI) {
		case 0: // llama.cpp
			return yield* await llamaCppCompletion({ endpoint, signal, ...options });
		case 1: // oobabooga
			return yield* await oobaCompletion({ endpoint, signal, ...options });
		case 2: // koboldcpp
			return yield* await koboldCppCompletion({ endpoint, signal, ...options });
		case 3: // openai
			return yield* await openaiCompletion({ endpoint, endpointAPIKey, signal, ...options });
	}
}

export async function abortCompletion({ endpoint, endpointAPI }) {
	switch (endpointAPI) {
		case 1: // oobabooga
			return await oobaAbortCompletion({ endpoint });
		case 2: // koboldcpp
			return await koboldCppAbortCompletion({ endpoint });
		case 3: // openai (ooba)
			return await openaiOobaAbortCompletion({ endpoint });
	}
}

// Function to parse text/event-stream data and yield JSON objects
async function* parseEventStream(eventStream) {
	let buf = '';
	let ignoreNextLf = false;

	for await (let chunk of eventStream.pipeThrough(new TextDecoderStream())) {
		// A CRLF could be split between chunks, so if the last chunk ended in
		// CR and this chunk started with LF, trim the LF
		if (ignoreNextLf && /^\n/.test(chunk)) {
			chunk = chunk.slice(1);
		}
		ignoreNextLf = /\r$/.test(chunk);

		// Event streams must be parsed line-by-line (ending in CR, LF, or CRLF)
		const lines = (buf + chunk).split(/\n|\r\n?/);
		buf = lines.pop();
		let type, data;

		for (const line of lines) {
			if (!line) {
				type = undefined;
				data = undefined;
				continue;
			}
			const { name, value } = /^(?<name>.*?)(?:: ?(?<value>.*))?$/s.exec(line).groups;
			switch (name) {
				case 'event':
					type = (value ?? '');
					break;
				case 'data':
					data = data === undefined ? (value ?? '') : `${data}\n${value}`;
					break;
			}
			// We only emit message-type events for now (and assume JSON)
			if (data && (type || 'message') === 'message') {
				const json = JSON.parse(data);
				// Both Chrome and Firefox suck at debugging
				// text/event-stream, so make it easier by logging events
				console.log('event', json);
				yield json;
				type = undefined;
				data = undefined;
			}
		}
	}
}

async function llamaCppTokenCount({ endpoint, signal, ...options }) {
	const res = await fetch(new URL('/tokenize', endpoint), {
		method: 'POST',
		headers: {
			'Content-Type': 'application/json',
		},
		body: JSON.stringify(options),
		signal,
	});
	if (!res.ok)
		throw new Error(`HTTP ${res.status}`);
	const { tokens } = await res.json();
	return tokens.length + 1; // + 1 for BOS, I guess.
}

async function* llamaCppCompletion({ endpoint, signal, ...options }) {
	const res = await fetch(new URL('/completion', endpoint), {
		method: 'POST',
		headers: {
			'Content-Type': 'application/json',
		},
		body: JSON.stringify({
			...options,
			stream: true,
		}),
		signal,
	});
	if (!res.ok)
		throw new Error(`HTTP ${res.status}`);
	return yield* await parseEventStream(res.body);
}

async function oobaTokenCount({ endpoint, signal, ...options }) {
	try {
		endpoint = `http:${endpoint.split(":")[1]}:5000`; // HACK!
		const res = await fetch(new URL('/api/v1/token-count', endpoint), {
			method: 'POST',
			headers: {
				'Content-Type': 'application/json',
			},
			body: JSON.stringify({
				prompt: options.content
			}),
			signal,
		});
		if (!res.ok)
			throw new Error(`HTTP ${res.status}`);
		const { results } = await res.json();
		return results[0].tokens;
	} catch (e) {
		reportError(e);
		return 0;
	}
}

function oobaConvertOptions(options) {
	const swapOption = (lhs, rhs) => {
		if (lhs in options) {
			options[rhs] = options[lhs];
			delete options[lhs];
		}
	};
	if (options.n_predict === -1) {
		options.n_predict = 1024;
	}
	swapOption("n_ctx", "truncation_length");
	swapOption("n_predict", "max_new_tokens");
	swapOption("repeat_penalty", "repetition_penalty");
	swapOption("repeat_last_n", "repetition_penalty_range");
	swapOption("ignore_eos", "ban_eos_token");
	swapOption("stop", "stopping_strings");
	return options;
}

async function* oobaCompletion({ endpoint, signal, ...options }) {
	const ws = new WebSocket(new URL('/api/v1/stream', endpoint));
	let connected = false;

	ws.onopen = () => {
		connected = true;
		ws.send(JSON.stringify(oobaConvertOptions(options)));
	};

	const wsStream = () => new EventIterator(
		queue => {
			ws.onmessage = queue.push;
			ws.onclose = queue.stop;
			ws.onerror = (e) => queue.fail(new Error(connected ? "WebSocket Error" : "Failed to connect"));
			if (signal) {
				signal.addEventListener("abort", queue.stop);
			}

			return () => {
				ws.close();
				if (signal) {
					signal.removeEventListener("abort", queue.stop);
				}
			}
		}
	);

	for await (const event of wsStream()) {
		const data = JSON.parse(event.data);
		console.log('event', data);

		if (data.event === "text_stream") {
			yield { content: data.text };
		} else if (data.event === "stream_end") {
			break;
		}
	}
}

async function oobaAbortCompletion({ endpoint }) {
	try {
		endpoint = `http:${endpoint.split(":")[1]}:5000`; // HACK!
		await fetch(new URL('/api/v1/stop-stream', endpoint), {
			method: 'POST',
		});
	} catch (e) {
		reportError(e);
	}
}

async function koboldCppTokenCount({ endpoint, signal, ...options }) {
	const res = await fetch(new URL('/api/extra/tokencount', endpoint), {
		method: 'POST',
		headers: {
			'Content-Type': 'application/json',
		},
		body: JSON.stringify({
			prompt: options.content
		}),
		signal,
	});
	if (!res.ok)
		throw new Error(`HTTP ${res.status}`);
	const { value } = await res.json();
	return value;
}

function koboldCppConvertOptions(options) {
	const swapOption = (lhs, rhs) => {
		if (lhs in options) {
			options[rhs] = options[lhs];
			delete options[lhs];
		}
	};
	if (options.n_predict === -1) {
		options.n_predict = 1024;
	}
	swapOption("n_ctx", "max_context_length");
	swapOption("n_predict", "max_length");
	swapOption("repeat_penalty", "rep_pen");
	swapOption("repeat_last_n", "rep_pen_range");
	swapOption("tfs_z", "tfs");
	swapOption("typical_p", "typical");
	swapOption("seed", "sampler_seed");
	swapOption("stop", "stop_sequence");
	swapOption("ignore_eos", "use_default_badwordsids");
	return options;
}

async function* koboldCppCompletion({ endpoint, signal, ...options }) {
	const res = await fetch(new URL('/api/extra/generate/stream', endpoint), {
		method: 'POST',
		headers: {
			'Content-Type': 'application/json',
		},
		body: JSON.stringify({
			...koboldCppConvertOptions(options),
			stream: true,
		}),
		signal,
	});
	if (!res.ok)
		throw new Error(`HTTP ${res.status}`);
	for await (const chunk of parseEventStream(res.body)) {
		yield { content: chunk.token };
	}
}

async function koboldCppAbortCompletion({ endpoint }) {
	await fetch(new URL('/api/extra/abort', endpoint), {
		method: 'POST',
	});
}

async function openaiOobaTokenCount({ endpoint, signal, ...options }) {
	try {
		const res = await fetch(new URL('/v1/internal/token-count', endpoint), {
			method: 'POST',
			headers: {
				'Content-Type': 'application/json',
			},
			body: JSON.stringify({
				prompt: options.content
			}),
			signal,
		});
		if (!res.ok)
			throw new Error(`HTTP ${res.status}`);
		const { results } = await res.json();
		return results[0].tokens;
	} catch (e) {
		reportError(e);
		return 0;
	}
}

async function openaiModels({ endpoint, endpointAPIKey, signal, ...options }) {
	try {
		const res = await fetch(new URL('/v1/models', endpoint), {
			method: 'GET',
			headers: {
				'Content-Type': 'application/json',
				'Authorization': `Bearer ${endpointAPIKey}`,
			},
			signal,
		});
		if (!res.ok)
			throw new Error(`HTTP ${res.status}`);
		const { data } = await res.json();
		return data.map(item => item.id);
	} catch (e) {
		reportError(e);
		return [];
	}
}

function openaiConvertOptions(options) {
	const swapOption = (lhs, rhs) => {
		if (lhs in options) {
			options[rhs] = options[lhs];
			delete options[lhs];
		}
	};
	if (options.n_predict === -1) {
		options.n_predict = 1024;
	}
	if (options.n_probs > 5) {
		options.n_probs = 5;
	}
	swapOption("n_ctx", "max_context_length");
	swapOption("n_predict", "max_tokens");
	swapOption("n_probs", "logprobs");
	return options;
}

async function* openaiCompletion({ endpoint, endpointAPIKey, signal, ...options }) {
	const res = await fetch(new URL('/v1/completions', endpoint), {
		method: 'POST',
		headers: {
			'Content-Type': 'application/json',
			'Authorization': `Bearer ${endpointAPIKey}`,
		},
		body: JSON.stringify({
			...openaiConvertOptions(options),
			stream: true,
		}),
		signal,
	});
	if (!res.ok)
		throw new Error(`HTTP ${res.status}`);
	for await (const chunk of parseEventStream(res.body)) {
		const logprobs = Object.entries(chunk.choices[0].logprobs?.top_logprobs?.[0] ?? {});
		const probs = logprobs.map(([tok, logprob]) => ({ tok_str: tok, prob: Math.exp(logprob) }));
		yield {
			content: chunk.choices[0].text,
			completion_probabilities: [{
				content: chunk.choices[0].text,
				probs
			}]
		};
	}
}

async function openaiOobaAbortCompletion({ endpoint }) {
	try {
		await fetch(new URL('/v1/internal/stop-generation', endpoint), {
			method: 'POST',
		});
	} catch (e) {
		reportError(e);
	}
}

function InputBox({ label, tooltip, value, type, datalist, onValueChange, ...props }) {
	return html`
		<label className="InputBox ${tooltip ? 'tooltip' : ''}">
			${label}
			<input
				type=${type || 'text'}
				list="${datalist ? label : ''}"
				value=${value}
				size="1"
				onChange=${({ target }) => {
					let value = type === 'number' ? target.valueAsNumber : target.value;
					if (props.inputmode === 'numeric') {
						props.pattern = '^-?[0-9]*$';
						if (value && !isNaN(+value))
							value = +target.value;
					}
					if (props.pattern && !new RegExp(props.pattern).test(value))
						return;
					onValueChange(value);
				}}
				...${props}/>
			${datalist && html`
				<datalist id="${label}">
					${datalist.map(opt => html`
						<option key="${opt}">
							${opt}
						</option>`)}
				</datalist>`}
			${tooltip && html`
				<span class="tooltiptext">
					${tooltip}
				</span>`}
		</label>`;
}

function SelectBox({ label, value, onValueChange, options, ...props }) {
	return html`
		<label className="SelectBox">
			${label}
			<select
				value=${value}
				onChange=${({ target }) => onValueChange(JSON.parse(target.value))}
				...${props}>
				${options.map(o => html`<option
					key=${JSON.stringify(o.value)}
					value=${JSON.stringify(o.value)}>${o.name}</option>`)}
			</select>
		</label>`;
}

function Checkbox({ label, value, onValueChange, ...props }) {
	return html`
		<label className="Checkbox">
			<input
				type="checkbox"
				checked=${value}
				onChange=${({ target }) => onValueChange(target.checked)}
				...${props}/>
			${label}
		</label>`;
}

function CollapsibleGroup({ label, expanded, children }) {
	const contentArea = useRef(null);
	const [contentHeight, setContentHeight] = useState(!expanded ? 0 : '');
	const [isCollapsed, setIsCollapsed] = useState(!expanded);

	useEffect(() => {
		setContentHeight(contentArea.current.scrollHeight);
		var observer = new MutationObserver(() => {
			setContentHeight(contentArea.current.scrollHeight);
		});
		observer.observe(contentArea.current, { subtree: true, childList: true });
		return () => observer.disconnect();
	}, []);

	const expandSvg = html`<svg fill="var(--color-light)" height="12" width="12" viewBox="0 0 330 330"><path d="M325.607,79.393c-5.857-5.857-15.355-5.858-21.213,0.001l-139.39,139.393L25.607,79.393 c-5.857-5.857-15.355-5.858-21.213,0.001c-5.858,5.858-5.858,15.355,0,21.213l150.004,150c2.813,2.813,6.628,4.393,10.606,4.393 s7.794-1.581,10.606-4.394l149.996-150C331.465,94.749,331.465,85.251,325.607,79.393z"/></svg>`;
	const collapseSvg = html`<svg fill="var(--color-light)" height="12" width="12" viewBox="0 0 330 330"><path d="M325.606,229.393l-150.004-150C172.79,76.58,168.974,75,164.996,75c-3.979,0-7.794,1.581-10.607,4.394 l-149.996,150c-5.858,5.858-5.858,15.355,0,21.213c5.857,5.857,15.355,5.858,21.213,0l139.39-139.393l139.397,139.393 C307.322,253.536,311.161,255,315,255c3.839,0,7.678-1.464,10.607-4.394C331.464,244.748,331.464,235.251,325.606,229.393z"/></svg>`;

	return html`
		<div className="collapsible-group">
			<div className="collapsible-header" onClick=${() => setIsCollapsed(!isCollapsed)}>
				${isCollapsed ? expandSvg : collapseSvg}
				${label}
			</div>
			<div
				ref=${contentArea}
				className="collapsible-content ${isCollapsed ? 'collapsed' : 'expanded'}"
				style=${{ 'max-height': isCollapsed ? 0 : contentHeight }}>
				${children}
			</div>
		</div>`;
}

function Sessions({ sessionStorage, onSessionChange, disabled }) {
	const [version, setVersion] = useState(0);
	const [newSessionName, setNewSessionName] = useState('');
	const [renameSessionName, setRenameSessionName] = useState('');
	const [isRenaming, setIsRenaming] = useState(false);
	const [isCreating, setIsCreating] = useState(false);

	useEffect(() => {
		sessionStorage.onchange = () => setVersion(v => v + 1);
		sessionStorage.onsessionchange = onSessionChange;
		return () => {
			sessionStorage.onchange = null;
			sessionStorage.onsessionchange = null;
		};
	}, []);

	const switchSession = (sessionId) => {
		if (sessionStorage.selectedSession != sessionId) {
			sessionStorage.switchSession(+sessionId);
		}
	};

	const startRenameSession = (sessionId, name) => {
		setRenameSessionName(name);
		setIsRenaming(sessionId);
	};

	const renameSession = (sessionId) => {
		if (renameSessionName) {
			sessionStorage.renameSession(sessionId, renameSessionName);
			setIsRenaming(false);
		}
	};

	const deleteSession = (sessionId) => {
		sessionStorage.deleteSession(sessionId);
	};

	const startCreateSession = () => {
		setNewSessionName(`MikuPad #${sessionStorage.nextId + 1}`);
		setIsCreating(true);
	};

	const createSession = () => {
		if (newSessionName) {
			const newId = sessionStorage.createSession(newSessionName);
			sessionStorage.switchSession(newId);
			setIsCreating(false);
		}
	};

	const importSession = () => {
		const fileInput = document.createElement("input");
		fileInput.type = 'file';
		fileInput.style.display = 'none';
		fileInput.onchange = (e) => {
			const file = e.target.files[0];
			if (!file)
				return;
			const reader = new FileReader();
			reader.onload = (e) => {
				const contents = e.target.result;
				fileInput.func(contents);
			}
			reader.readAsText(file);
		};
		fileInput.func = (text) => {
			const newId = sessionStorage.createSessionFromObject(JSON.parse(text));
			sessionStorage.switchSession(newId);
		};
		document.body.appendChild(fileInput);
		fileInput.click();
		document.body.removeChild(fileInput);
	};

	const exportSession = () => {
		var element = document.createElement('a');
		const sessionObj = { ...sessionStorage.sessions[sessionStorage.selectedSession] };
		for (const [key, value] of Object.entries(sessionObj)) {
			// This is done for compatibility with localStorage export files.
			sessionObj[key] = JSON.stringify(value);
		}
		element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(JSON.stringify(sessionObj)));
		element.setAttribute('download', `${sessionStorage.getProperty('name')}.json`);
		element.style.display = 'none';
		document.body.appendChild(element);
		element.click();
		document.body.removeChild(element);
	};

	function handleKeyDown(sessionId, key) {
		if (event.key === 'Enter') {
			if (isCreating)
				createSession();
			else if (isRenaming)
				renameSession(sessionId);
		} else if (event.key === 'Escape') {
			if (isCreating)
				setIsCreating(false);
			else if (isRenaming)
				setIsRenaming(false);
		}
	}

	const trashSvg = html`<svg fill="var(--color-light)" width="16" height="16" viewBox="0 0 490.646 490.646"><path d="m399.179 67.285-74.794.033L324.356 0 166.214.066l.029 67.318-74.802.033.025 62.914h307.739l-.026-63.046zM198.28 32.11l94.03-.041.017 35.262-94.03.041-.017-35.262zM91.465 490.646h307.739V146.359H91.465v344.287zm225.996-297.274h16.028v250.259h-16.028V193.372zm-80.14 0h16.028v250.259h-16.028V193.372zm-80.141 0h16.028v250.259H157.18V193.372z"/></svg>`;
	const renameSvg = html`<svg fill="var(--color-light)" width="16" height="16" viewBox="0 0 512 448"><path style=${{ fillOpacity: 1, stroke: 'none', strokeWidth: 30, strokeLinecap: 'round', strokeMiterlimit: 4, strokeDasharray: 'none', strokeOpacity: 1 }} d="M0 96v256h320v-32H32V128h288V96H0zM416 96v32h64v192h-64v32h96V96h-96z" /><path style=${{ fillOpacity: 1, stroke: 'none', strokeWidth: 30, strokeLinecap: 'round', strokeMiterlimit: 4, strokeDasharray: 'none', strokeOpacity: 1 }} d="M352 636.362h32v384h-32z" transform="matrix(1, 0, 0, 1, 0, -604.3619995117188)" /><path style=${{ fillOpacity: 1, stroke: 'none', strokeWidth: 30, strokeLinecap: 'round', strokeMiterlimit: 4, strokeDasharray: 'none', strokeOpacity: 1 }} transform="matrix(0, 1, -1, 0, 0, -604.3619995117188)" d="M1020.362-448h32v64h-32zM1020.362-352h32v64h-32zM604.362-448h32v64h-32zM604.362-352h32v64h-32zM764.362-288h128v224h-128z" /></svg>`;

	const confirmSvg = html`<svg width="16" height="16" viewBox="0 0 128 128"><circle cx="64" cy="64" r="64" fill="var(--color-dark)"/><path d="M54.3 97.2 24.8 67.7c-.4-.4-.4-1 0-1.4l8.5-8.5c.4-.4 1-.4 1.4 0L55 78.1l38.2-38.2c.4-.4 1-.4 1.4 0l8.5 8.5c.4.4.4 1 0 1.4L55.7 97.2c-.4.4-1 .4-1.4 0z" fill="var(--color-light)"/></svg>`;
	const cancelSvg = html`<svg width="16" height="16" viewBox="0 0 128 128"><circle cx="64" cy="64" r="64" fill="var(--color-dark)"/><path d="M100.3 90.4 73.9 64l26.3-26.4c.4-.4.4-1 0-1.4l-8.5-8.5c-.4-.4-1-.4-1.4 0L64 54.1 37.7 27.8c-.4-.4-1-.4-1.4 0l-8.5 8.5c-.4.4-.4 1 0 1.4L54 64 27.7 90.3c-.4.4-.4 1 0 1.4l8.5 8.5c.4.4 1.1.4 1.4 0L64 73.9l26.3 26.3c.4.4 1.1.4 1.5.1l8.5-8.5c.4-.4.4-1 0-1.4z" fill="var(--color-light)"/></svg>`;

	return html`
		<div className="Sessions ${disabled ? 'disabled' : ''}">
			<ul>
				${isCreating && html`
					<li key=-1>
						<a className="Session">
							<input
								type="text"
								value=${newSessionName}
								onChange=${(e) => setNewSessionName(e.target.value)}
								onKeyDown=${(e) => handleKeyDown(sessionId, e.key)}
								onClick=${(e) => e.stopPropagation()}
								autoFocus
							/>
							<div className="flex-separator"></div>
							<button onClick=${(e) => (createSession(), e.stopImmediatePropagation?.())}>${confirmSvg}</button>
							<button onClick=${(e) => (setIsCreating(false), e.stopImmediatePropagation?.())}>${cancelSvg}</button>
						</a>
					</li>
				`}
				${Object.entries(sessionStorage.sessions).reverse().map(([sessionId, session]) => html`
					<li key=${sessionId}>
						<a className="Session ${sessionStorage.selectedSession == sessionId ? 'selected' : ''}"
							onClick=${() => switchSession(sessionId)}>
							${isRenaming === sessionId ? html`
								<input
									type="text"
									value=${renameSessionName}
									onChange=${(e) => setRenameSessionName(e.target.value)}
									onKeyDown=${(e) => handleKeyDown(sessionId, e.key)}
									onClick=${(e) => e.stopPropagation()}
									autoFocus
								/>
								<div className="flex-separator"></div>
								<button onClick=${(e) => (renameSession(sessionId), e.stopImmediatePropagation())}>${confirmSvg}</button>
								<button onClick=${(e) => (setIsRenaming(false), e.stopImmediatePropagation())}>${cancelSvg}</button>
							` : html`
								${session.name}
								<div className="flex-separator"></div>
								<button
									onClick=${(e) => (startRenameSession(sessionId, session.name), e.stopPropagation())}>
									${renameSvg}
								</button>
								<button
									onClick=${(e) => (deleteSession(sessionId), e.stopPropagation())}>
									${trashSvg}
								</button>
							`}
						</a>
					</li>
				`)}
			</ul>
			<div className="vbox">
				<button disabled=${disabled} onClick=${startCreateSession}>Create</button>
				<button disabled=${disabled} onClick=${importSession}>Import</button>
				<button disabled=${disabled} onClick=${exportSession}>Export</button>
			</div>
		</div>`;
}

class SessionStorage {
	constructor(defaultPresets) {
		this.nextId = +localStorage.getItem('nextSessionId');
		this.dependents = {};
		this.saveQueue = [];
		this.saveTimer = setInterval(() => this.saveTimerHandler(), 1000);
		this.sessions = {};
		this.selectedSession = +localStorage.getItem('selectedSessionId');
		this.sessionTemplate = { ...defaultPresets };
		this.onchange = null;
		this.onsessionchange = null;
		this.loadFromStorage();
	}

	getNewId() {
		this.nextId += 1;
		localStorage.setItem('nextSessionId', this.nextId);
		return this.nextId - 1;
	}

	addDependent(name, callback) {
		this.dependents[name] = this.dependents[name] || new Set();
		this.dependents[name].add(callback);
	}

	updateDependents(name, newValue) {
		if (this.dependents[name]) {
			for (const callback of this.dependents[name]) {
				callback(newValue);
			}
		}
	}

	saveTimerHandler() {
		while (this.saveQueue.length) {
			const [sessionId, propertyName] = this.saveQueue.pop().split('/');
			this.savePropertyToStorage(+sessionId, propertyName);
		}
	}

	loadFromStorage() {
		const needsMigration = localStorage.getItem('selectedSessionId') == null;
		if (needsMigration) {
			const newId = this.createSession('MikuPad #1');
			for (const propertyName of Object.keys(localStorage)) {
				if (propertyName === 'darkMode' || propertyName === 'nextSessionId' || propertyName.startsWith(`${newId}/`)) continue;
				let value = localStorage.getItem(propertyName);
				try {
					value = JSON.parse(value);
				} catch {
					// This might have been added to the localStorage by a extension rather than us. Let's just skip it.
					continue;
				}
				localStorage.removeItem(propertyName);
				if (value !== null) {
					this.sessions[newId][propertyName] = value;
					this.savePropertyToStorage(newId, propertyName);
				}
			}
			this.switchSession(newId);
		} else {
			for (const key of Object.keys(localStorage)) {
				const [sessionId, propertyName] = key.split('/');
				if (propertyName === undefined) continue;
				const value = this.loadPropertyFromStorage(sessionId, propertyName);
				if (value !== null) {
					this.sessions[sessionId] = this.sessions[sessionId] || {};
					this.sessions[sessionId][propertyName] = value;
				}
			};
			this.switchSession(this.selectedSession);
		}
	}

	saveToStorage() {
		for (const sessionId of Object.keys(this.sessions)) {
			for (const propertyName of Object.keys(this.sessions[sessionId])) {
				this.savePropertyToStorage(sessionId, propertyName);
			}
		}
	}

	loadPropertyFromStorage(sessionId, propertyName) {
		return JSON.parse(localStorage.getItem(`${sessionId}/${propertyName}`));
	}

	savePropertyToStorage(sessionId, propertyName) {
		const value = this.sessions[sessionId][propertyName];
		localStorage.setItem(`${sessionId}/${propertyName}`, JSON.stringify(value));
	}

	deletePropertyFromStorage(sessionId, propertyName) {
		localStorage.removeItem(`${sessionId}/${propertyName}`);
	}

	getProperty(propertyName) {
		return this.sessions[this.selectedSession]?.[propertyName];
	}

	setProperty(propertyName, value) {
		if (this.sessions[this.selectedSession]) {
			this.sessions[this.selectedSession][propertyName] = value;
			if (this.saveQueue.indexOf(`${this.selectedSession}/${propertyName}`) === -1)
				this.saveQueue.push(`${this.selectedSession}/${propertyName}`);
		}
	}

	switchSession(sessionId) {
		this.selectedSession = sessionId;
		localStorage.setItem('selectedSessionId', sessionId);
		this.onchange?.();
		this.onsessionchange?.();
		for (const propertyName of Object.keys(this.sessionTemplate)) {
			this.updateDependents(propertyName, this.getProperty(propertyName) ?? this.sessionTemplate[propertyName]);
		}
	}

	renameSession(sessionId, renameSessionName) {
		this.sessions[sessionId]['name'] = renameSessionName;
		this.savePropertyToStorage(sessionId, 'name');
		this.onchange?.();
	}

	deleteSession(sessionId) {
		if (Object.keys(this.sessions).length === 1)
			return;
		if (!window.confirm("Are you sure you want to delete this session? This action can't be undone."))
			return;
		if (sessionId == this.selectedSession) {
			const sessionIds = Object.keys(this.sessions);
			const sessionIdx = sessionIds.indexOf(sessionId);
			const newSessionId = sessionIds[sessionIdx - 1] ?? sessionIds[sessionIdx + 1];
			this.switchSession(+newSessionId)
		}
		for (const propertyName of Object.keys(this.sessions[sessionId])) {
			this.deletePropertyFromStorage(sessionId, propertyName);
		}
		delete this.sessions[sessionId];
		this.onchange?.();
	}

	createSession(newSessionName) {
		const newId = this.getNewId();
		this.sessions[newId] = { name: newSessionName };
		this.savePropertyToStorage(newId, 'name');
		onchange?.();
		return newId;
	}

	createSessionFromObject(obj) {
		const newId = this.getNewId();
		this.sessions[newId] = {};
		for (const [propertyName, value] of Object.entries(obj)) {
			if (propertyName === 'darkMode') continue;
			this.sessions[newId][propertyName] = JSON.parse(value);
			this.savePropertyToStorage(newId, propertyName);
		}
		if (!this.sessions[newId].hasOwnProperty('name')) {
			this.sessions[newId]['name'] = `MikuPad #${this.nextId + 1}`;
			this.savePropertyToStorage(newId, 'name');
		}
		onchange?.();
		return newId;
	}
}

const defaultPrompt = `[INST] <<SYS>>
You are a talented writing assistant. Always respond by incorporating the instructions into expertly written prose that is highly detailed, evocative, vivid and engaging.
<</SYS>>

Write a story about Hatsune Miku and Kagamine Rin. [/INST]  Sure, how about this:

Chapter 1
`;

const defaultPresets = {
	endpoint: 'http://127.0.0.1:8080',
	endpointAPI: 0,
	endpointAPIKey: '',
	endpointModel: '',
	prompt: [{ type: 'user', content: defaultPrompt }],
	seed: -1,
	maxPredictTokens: -1,
	temperature: 0.7,
	repeatPenalty: 1.1,
	repeatLastN: 256,
	penalizeNl: true,
	presencePenalty: 0,
	frequencyPenalty: 0,
	topK: 40,
	topP: 0.95,
	typicalP: 1,
	minP: 0,
	tfsZ: 1,
	mirostat: 2,
	mirostatTau: 5.0,
	mirostatEta: 0.1,
	ignoreEos: false,
	openaiPresets: true,
};

function joinPrompt(prompt) {
	return prompt.map(p => p.content).join('');
}

function replaceUnprintableBytes(inputString) {
  // Define a regular expression to match unprintable bytes
  const unprintableBytesRegex = /[\0-\x1F\x7F-\x9F\xAD\u0378\u0379\u037F-\u0383\u038B\u038D\u03A2\u0528-\u0530\u0557\u0558\u0560\u0588\u058B-\u058E\u0590\u05C8-\u05CF\u05EB-\u05EF\u05F5-\u0605\u061C\u061D\u06DD\u070E\u070F\u074B\u074C\u07B2-\u07BF\u07FB-\u07FF\u082E\u082F\u083F\u085C\u085D\u085F-\u089F\u08A1\u08AD-\u08E3\u08FF\u0978\u0980\u0984\u098D\u098E\u0991\u0992\u09A9\u09B1\u09B3-\u09B5\u09BA\u09BB\u09C5\u09C6\u09C9\u09CA\u09CF-\u09D6\u09D8-\u09DB\u09DE\u09E4\u09E5\u09FC-\u0A00\u0A04\u0A0B-\u0A0E\u0A11\u0A12\u0A29\u0A31\u0A34\u0A37\u0A3A\u0A3B\u0A3D\u0A43-\u0A46\u0A49\u0A4A\u0A4E-\u0A50\u0A52-\u0A58\u0A5D\u0A5F-\u0A65\u0A76-\u0A80\u0A84\u0A8E\u0A92\u0AA9\u0AB1\u0AB4\u0ABA\u0ABB\u0AC6\u0ACA\u0ACE\u0ACF\u0AD1-\u0ADF\u0AE4\u0AE5\u0AF2-\u0B00\u0B04\u0B0D\u0B0E\u0B11\u0B12\u0B29\u0B31\u0B34\u0B3A\u0B3B\u0B45\u0B46\u0B49\u0B4A\u0B4E-\u0B55\u0B58-\u0B5B\u0B5E\u0B64\u0B65\u0B78-\u0B81\u0B84\u0B8B-\u0B8D\u0B91\u0B96-\u0B98\u0B9B\u0B9D\u0BA0-\u0BA2\u0BA5-\u0BA7\u0BAB-\u0BAD\u0BBA-\u0BBD\u0BC3-\u0BC5\u0BC9\u0BCE\u0BCF\u0BD1-\u0BD6\u0BD8-\u0BE5\u0BFB-\u0C00\u0C04\u0C0D\u0C11\u0C29\u0C34\u0C3A-\u0C3C\u0C45\u0C49\u0C4E-\u0C54\u0C57\u0C5A-\u0C5F\u0C64\u0C65\u0C70-\u0C77\u0C80\u0C81\u0C84\u0C8D\u0C91\u0CA9\u0CB4\u0CBA\u0CBB\u0CC5\u0CC9\u0CCE-\u0CD4\u0CD7-\u0CDD\u0CDF\u0CE4\u0CE5\u0CF0\u0CF3-\u0D01\u0D04\u0D0D\u0D11\u0D3B\u0D3C\u0D45\u0D49\u0D4F-\u0D56\u0D58-\u0D5F\u0D64\u0D65\u0D76-\u0D78\u0D80\u0D81\u0D84\u0D97-\u0D99\u0DB2\u0DBC\u0DBE\u0DBF\u0DC7-\u0DC9\u0DCB-\u0DCE\u0DD5\u0DD7\u0DE0-\u0DF1\u0DF5-\u0E00\u0E3B-\u0E3E\u0E5C-\u0E80\u0E83\u0E85\u0E86\u0E89\u0E8B\u0E8C\u0E8E-\u0E93\u0E98\u0EA0\u0EA4\u0EA6\u0EA8\u0EA9\u0EAC\u0EBA\u0EBE\u0EBF\u0EC5\u0EC7\u0ECE\u0ECF\u0EDA\u0EDB\u0EE0-\u0EFF\u0F48\u0F6D-\u0F70\u0F98\u0FBD\u0FCD\u0FDB-\u0FFF\u10C6\u10C8-\u10CC\u10CE\u10CF\u1249\u124E\u124F\u1257\u1259\u125E\u125F\u1289\u128E\u128F\u12B1\u12B6\u12B7\u12BF\u12C1\u12C6\u12C7\u12D7\u1311\u1316\u1317\u135B\u135C\u137D-\u137F\u139A-\u139F\u13F5-\u13FF\u169D-\u169F\u16F1-\u16FF\u170D\u1715-\u171F\u1737-\u173F\u1754-\u175F\u176D\u1771\u1774-\u177F\u17DE\u17DF\u17EA-\u17EF\u17FA-\u17FF\u180F\u181A-\u181F\u1878-\u187F\u18AB-\u18AF\u18F6-\u18FF\u191D-\u191F\u192C-\u192F\u193C-\u193F\u1941-\u1943\u196E\u196F\u1975-\u197F\u19AC-\u19AF\u19CA-\u19CF\u19DB-\u19DD\u1A1C\u1A1D\u1A5F\u1A7D\u1A7E\u1A8A-\u1A8F\u1A9A-\u1A9F\u1AAE-\u1AFF\u1B4C-\u1B4F\u1B7D-\u1B7F\u1BF4-\u1BFB\u1C38-\u1C3A\u1C4A-\u1C4C\u1C80-\u1CBF\u1CC8-\u1CCF\u1CF7-\u1CFF\u1DE7-\u1DFB\u1F16\u1F17\u1F1E\u1F1F\u1F46\u1F47\u1F4E\u1F4F\u1F58\u1F5A\u1F5C\u1F5E\u1F7E\u1F7F\u1FB5\u1FC5\u1FD4\u1FD5\u1FDC\u1FF0\u1FF1\u1FF5\u1FFF\u200B-\u200F\u202A-\u202E\u2060-\u206F\u2072\u2073\u208F\u209D-\u209F\u20BB-\u20CF\u20F1-\u20FF\u218A-\u218F\u23F4-\u23FF\u2427-\u243F\u244B-\u245F\u2700\u2B4D-\u2B4F\u2B5A-\u2BFF\u2C2F\u2C5F\u2CF4-\u2CF8\u2D26\u2D28-\u2D2C\u2D2E\u2D2F\u2D68-\u2D6E\u2D71-\u2D7E\u2D97-\u2D9F\u2DA7\u2DAF\u2DB7\u2DBF\u2DC7\u2DCF\u2DD7\u2DDF\u2E3C-\u2E7F\u2E9A\u2EF4-\u2EFF\u2FD6-\u2FEF\u2FFC-\u2FFF\u3040\u3097\u3098\u3100-\u3104\u312E-\u3130\u318F\u31BB-\u31BF\u31E4-\u31EF\u321F\u32FF\u4DB6-\u4DBF\u9FCD-\u9FFF\uA48D-\uA48F\uA4C7-\uA4CF\uA62C-\uA63F\uA698-\uA69E\uA6F8-\uA6FF\uA78F\uA794-\uA79F\uA7AB-\uA7F7\uA82C-\uA82F\uA83A-\uA83F\uA878-\uA87F\uA8C5-\uA8CD\uA8DA-\uA8DF\uA8FC-\uA8FF\uA954-\uA95E\uA97D-\uA97F\uA9CE\uA9DA-\uA9DD\uA9E0-\uA9FF\uAA37-\uAA3F\uAA4E\uAA4F\uAA5A\uAA5B\uAA7C-\uAA7F\uAAC3-\uAADA\uAAF7-\uAB00\uAB07\uAB08\uAB0F\uAB10\uAB17-\uAB1F\uAB27\uAB2F-\uABBF\uABEE\uABEF\uABFA-\uABFF\uD7A4-\uD7AF\uD7C7-\uD7CA\uD7FC-\uF8FF\uFA6E\uFA6F\uFADA-\uFAFF\uFB07-\uFB12\uFB18-\uFB1C\uFB37\uFB3D\uFB3F\uFB42\uFB45\uFBC2-\uFBD2\uFD40-\uFD4F\uFD90\uFD91\uFDC8-\uFDEF\uFDFE\uFDFF\uFE1A-\uFE1F\uFE27-\uFE2F\uFE53\uFE67\uFE6C-\uFE6F\uFE75\uFEFD-\uFF00\uFFBF-\uFFC1\uFFC8\uFFC9\uFFD0\uFFD1\uFFD8\uFFD9\uFFDD-\uFFDF\uFFE7\uFFEF-\uFFFB\uFFFE\uFFFF]/g;

  // Replace unprintable bytes with their character codes
  const replacedString = inputString.replace(unprintableBytesRegex, (match) => {
    const charCode = match.charCodeAt(0);
    return `<0x${charCode.toString(16).toUpperCase().padStart(2, '0')}>`;
  });

  return replacedString;
}

function useSessionStorage(defaultPresets) {
	const ref = useRef();
	if (!ref.current)
		ref.current = new SessionStorage(defaultPresets);
	return [ref.current, (name, initialState) => useSessionState(ref.current, name, initialState)];
}

function useSessionState(sessionStorage, name, initialState) {
	const savedState = useMemo(() => {
		try {
			return sessionStorage.getProperty(name);
		} catch (e) {
			reportError(e);
			return null;
		}
	}, []);

	const [value, setValue] = useState(savedState ?? initialState);
	sessionStorage.addDependent(name, setValue);

	const updateState = (newValue) => {
		setValue((prevValue) => {
			const updatedValue = typeof newValue === 'function' ? newValue(prevValue) : newValue;
			sessionStorage.setProperty(name, updatedValue);
			return updatedValue;
		});
	};

	return [value, updateState];
}

function usePersistentState(name, initialState) {
	const savedState = useMemo(() => {
		try {
			return JSON.parse(localStorage.getItem(name));
		} catch (e) {
			reportError(e);
			return null;
		}
	}, []);

	const [value, setValue] = useState(savedState ?? initialState);

	const updateState = (newValue) => {
		setValue((prevValue) => {
			const updatedValue = typeof newValue === 'function' ? newValue(prevValue) : newValue;
			localStorage.setItem(name, JSON.stringify(updatedValue));
			return updatedValue;
		});
	};

	return [value, updateState];
}

export function App() {
	const [sessionStorage, useSessionState] = useSessionStorage(defaultPresets);
	const promptArea = useRef();
	const promptOverlay = useRef();
	const undoStack = useRef([]);
	const redoStack = useRef([]);
	const probsDelayTimer = useRef();
	const [currentPromptChunk, setCurrentPromptChunk] = useState(undefined);
	const [undoHovered, setUndoHovered] = useState(false);
	const [showProbs, setShowProbs] = useState(true);
	const [cancel, setCancel] = useState(null);
	const [darkMode, setDarkMode] = usePersistentState('darkMode', false);
	const [endpoint, setEndpoint] = useSessionState('endpoint', defaultPresets.endpoint);
	const [endpointAPI, setEndpointAPI] = useSessionState('endpointAPI', defaultPresets.endpointAPI);
	const [endpointAPIKey, setEndpointAPIKey] = useSessionState('endpointAPIKey', defaultPresets.endpointAPIKey);
	const [endpointModel, setEndpointModel] = useSessionState('endpointModel', defaultPresets.endpointModel);
	const [promptChunks, setPromptChunks] = useSessionState('prompt', defaultPresets.prompt);
	const [seed, setSeed] = useSessionState('seed', defaultPresets.seed);
	const [maxPredictTokens, setMaxPredictTokens] = useSessionState('maxPredictTokens', defaultPresets.maxPredictTokens);
	const [temperature, setTemperature] = useSessionState('temperature', defaultPresets.temperature);
	const [repeatPenalty, setRepeatPenalty] = useSessionState('repeatPenalty', defaultPresets.repeatPenalty);
	const [repeatLastN, setRepeatLastN] = useSessionState('repeatLastN', defaultPresets.repeatLastN);
	const [penalizeNl, setPenalizeNl] = useSessionState('penalizeNl', defaultPresets.penalizeNl);
	const [presencePenalty, setPresencePenalty] = useSessionState('presencePenalty', defaultPresets.presencePenalty);
	const [frequencyPenalty, setFrequencyPenalty] = useSessionState('frequencyPenalty', defaultPresets.frequencyPenalty);
	const [topK, setTopK] = useSessionState('topK', defaultPresets.topK);
	const [topP, setTopP] = useSessionState('topP', defaultPresets.topP);
	const [typicalP, setTypicalP] = useSessionState('typicalP', defaultPresets.typicalP);
	const [minP, setMinP] = useSessionState('minP', defaultPresets.minP);
	const [tfsZ, setTfsZ] = useSessionState('tfsZ', defaultPresets.tfsZ);
	const [mirostat, setMirostat] = useSessionState('mirostat', defaultPresets.mirostat);
	const [mirostatTau, setMirostatTau] = useSessionState('mirostatTau', defaultPresets.mirostatTau);
	const [mirostatEta, setMirostatEta] = useSessionState('mirostatEta', defaultPresets.mirostatEta);
	const [ignoreEos, setIgnoreEos] = useSessionState('ignoreEos', defaultPresets.ignoreEos);
	const [openaiPresets, setOpenaiPresets] = useSessionState('openaiPresets', defaultPresets.openaiPresets);
	const [openaiModels, setOpenaiModels] = useState([]);
	const [tokens, setTokens] = useState(0);
	const [predictStartTokens, setPredictStartTokens] = useState(0);
	const [lastError, setLastError] = useState(undefined);

	const promptText = useMemo(() => joinPrompt(promptChunks), [promptChunks]);

	// Update dark mode on the first render.
	useMemo(() => !darkMode || switchDarkMode(darkMode, true), []);

	async function predict(prompt = promptText, chunkCount = promptChunks.length) {
		if (cancel) {
			cancel?.();

			// llama.cpp server sometimes generates gibberish if we stop and
			// restart right away (???)
			let cancelled = false;
			setCancel(() => () => cancelled = true);
			await new Promise(resolve => setTimeout(resolve, 500));
			if (cancelled)
				return;
		}

		const ac = new AbortController();
		const cancelThis = () => {
			abortCompletion({ endpoint, endpointAPI });
			ac.abort();
		};
		setCancel(() => cancelThis);
		setLastError(undefined);

		let predictedChunkCount = 0;
		try {
			// sometimes "getTokenCount" can take a while because the server is busy
			// so let's set the predictStartTokens beforehand.
			setPredictStartTokens(tokens);

			const tokenCount = await getTokenCount({
				endpoint,
				endpointAPI,
				content: ` ${prompt}`,
				signal: ac.signal,
			});
			setTokens(tokenCount);
			setPredictStartTokens(tokenCount);

			while (undoStack.current.at(-1) >= chunkCount)
				undoStack.current.pop();
			undoStack.current.push(chunkCount);
			redoStack.current = [];
			setUndoHovered(false);

			for await (const chunk of completion({
				endpoint,
				endpointAPI,
				...(endpointAPI == 3 ? {
					endpointAPIKey,
					model: endpointModel
				} : {}),
				prompt,
				...(seed != -1 ? { seed } : {}),
				temperature,
				...(!openaiPresets || endpointAPI != 3 ? {
					repeat_penalty: repeatPenalty,
					repeat_last_n: repeatLastN,
					penalize_nl: penalizeNl,
					ignore_eos: ignoreEos,
				} : {}),
				presence_penalty: presencePenalty,
				frequency_penalty: frequencyPenalty,
				mirostat,
				...(mirostat ? {
					mirostat_tau: mirostatTau,
					mirostat_eta: mirostatEta,
				} : {
					top_p: topP,
					...(!openaiPresets || endpointAPI != 3 ? {
						top_k: topK,
						typical_p: typicalP,
						min_p: minP,
						tfs_z: tfsZ
					} : {})
				}),
				n_predict: maxPredictTokens,
				n_probs: 10,
				signal: ac.signal,
			})) {
				ac.signal.throwIfAborted();
				if (!chunk.content)
					continue;
				setPromptChunks(p => [...p, chunk]);
				setTokens(t => t + (chunk?.completion_probabilities?.length ?? 1));
				chunkCount += 1;
			}
		} catch (e) {
			if (e.name !== 'AbortError') {
				reportError(e);
				setLastError(e.toString());
			}
			return false;
		} finally {
			setCancel(c => c === cancelThis ? null : c);
			if (undoStack.current.at(-1) === chunkCount)
				undoStack.current.pop();
		}
	}

	function undo() {
		if (!undoStack.current.length)
			return;
		redoStack.current.push(promptChunks.slice(undoStack.current.at(-1)));
		setPromptChunks(p => p.slice(0, undoStack.current.pop()));
	}

	function redo() {
		if (!redoStack.current.length)
			return;
		undoStack.current.push(promptChunks.length);
		setPromptChunks(p => [...p, ...redoStack.current.pop()]);
		setUndoHovered(false);
	}

	useEffect(() => {
		const adjustProbsPosition = () => {
			const probsElement = document.getElementById('probs');
			if (!probsElement) return;

			probsElement.style.display = '';
			probsElement.style.setProperty('--probs-top', `${currentPromptChunk.top}px`);
			probsElement.style.setProperty('--probs-left', `${currentPromptChunk.left}px`);

			const probsRect = probsElement.getBoundingClientRect();
			const viewportWidth = window.innerWidth || document.documentElement.clientWidth;
			const viewportHeight = window.innerHeight || document.documentElement.clientHeight;

			// Adjust left position if element goes off-screen on the right
			if (probsRect.right > viewportWidth) {
				const newLeft = viewportWidth - probsRect.width / 2;
				probsElement.style.setProperty('--probs-left', `${newLeft}px`);
			}

			// Adjust right position if element goes off-screen on the left
			if (probsRect.left < 0) {
				probsElement.style.setProperty('--probs-left', `${probsRect.width / 2}px`);
			}
		};

		if (currentPromptChunk && showProbs) {
			setTimeout(() => {
				adjustProbsPosition();
			});
		}
	}, [currentPromptChunk, showProbs]);

	// Update the textarea in an uncontrolled way so the user doesn't lose their
	// selection or cursor position during prediction
	useEffect(() => {
		const elem = promptArea.current;
		if (elem.value === promptText) {
			return;
		} else if (promptText.startsWith(elem.value)) {
			const oldHeight = elem.scrollHeight;
			const atBottom = (elem.scrollTarget ?? elem.scrollTop) + elem.clientHeight + 1 > oldHeight;
			const oldLen = elem.value.length;
			elem.setRangeText(promptText.slice(oldLen), oldLen, oldLen, 'preserve');
			const newHeight = elem.scrollHeight;
			if (atBottom && oldHeight !== newHeight) {
				elem.scrollTarget = newHeight - elem.clientHeight;
				elem.scrollTo({
					top: newHeight - elem.clientHeight,
					behavior: 'smooth',
				});
			}
		} else {
			elem.value = promptText;
		}
	}, [promptText]);

	useEffect(() => {
		if (cancel)
			return;
		const ac = new AbortController();
		const to = setTimeout(async () => {
			try {
				const tokenCount = await getTokenCount({
					endpoint,
					endpointAPI,
					content: ` ${promptText}`,
					signal: ac.signal,
				});
				setTokens(tokenCount);
			} catch (e) {
				if (e.name !== 'AbortError')
					reportError(e);
			}
		}, 500);
		ac.signal.addEventListener('abort', () => clearTimeout(to));
		return () => ac.abort();
	}, [promptText, cancel, endpoint, endpointAPI]);

	useEffect(() => {
		const ac = new AbortController();
		const to = setTimeout(async () => {
			try {
				const models = await getModels({
					endpoint,
					endpointAPI,
					...(endpointAPI == 3 ? { endpointAPIKey } : {}),
					signal: ac.signal,
				});
				setOpenaiModels(models);
			} catch (e) {
				if (e.name !== 'AbortError')
					reportError(e);
			}
		}, 500);
		ac.signal.addEventListener('abort', () => clearTimeout(to));
		return () => ac.abort();
	}, [endpoint, endpointAPI, endpointAPIKey]);

	useEffect(() => {
		function onKeyDown(e) {
			const { altKey, ctrlKey, shiftKey, key, defaultPrevented } = e;
			if (defaultPrevented)
				return;
			switch (`${altKey}:${ctrlKey}:${shiftKey}:${key}`) {
			case 'false:false:true:Enter':
			case 'false:true:false:Enter':
				predict();
				break;
			case 'false:false:false:Escape':
				cancel();
				break;
			default:
				return;
			}
			e.preventDefault();
		}

		window.addEventListener('keydown', onKeyDown);
		return () => window.removeEventListener('keydown', onKeyDown);
	}, [predict, cancel]);

	function onInput({ target }) {
		setPromptChunks(oldPrompt => {
			const start = [];
			const end = [];
			const oldPromptLength = oldPrompt.length;
			oldPrompt = [...oldPrompt];
			let newValue = target.value;

			while (oldPrompt.length) {
				const chunk = oldPrompt[0];
				if (!newValue.startsWith(chunk.content))
					break;
				oldPrompt.shift();
				start.push(chunk);
				newValue = newValue.slice(chunk.content.length);
			}

			while (oldPrompt.length) {
				const chunk = oldPrompt.at(-1);
				if (!newValue.endsWith(chunk.content))
					break;
				oldPrompt.pop();
				end.unshift(chunk);
				newValue = newValue.slice(0, -chunk.content.length);
			}

			// Remove all undo positions within the modified range.
			undoStack.current = undoStack.current.filter(pos => start.length < pos);
			if (!undoStack.current.length)
				setUndoHovered(false);

			// Update all undo positions.
			if (start.length + end.length + (+!!newValue) !== oldPromptLength) {
				// Reset redo stack if a new chunk is added/removed at the end.
				if (!end.length)
					redoStack.current = [];

				if (!oldPrompt.length)
					undoStack.current = undoStack.current.map(pos => pos + 1);
				else
					undoStack.current = undoStack.current.map(pos => pos - oldPrompt.length);
			}

			const newPrompt = [
				...start,
				...(newValue ? [{ type: 'user', content: newValue }] : []),
				...end,
			];
			if (cancel)
				predict(joinPrompt(newPrompt), newPrompt.length);
			return newPrompt;
		});
	}

	function onScroll({ target }) {
		if (target.scrollTop === target.scrollTarget)
			target.scrollTarget = undefined;

		const newTop = target.scrollTop;
		const oldTop = promptOverlay.current.scrollTop;
		promptOverlay.current.scrollTop = target.scrollTop;
		promptOverlay.current.scrollLeft = target.scrollLeft;

		const probsElement = document.getElementById('probs');
		if (probsElement) {
			const probsTop = getComputedStyle(probsElement).getPropertyValue('top');
			probsElement.style.setProperty('--probs-top', `calc(${probsTop} + ${oldTop - newTop}px)`);
		} else if (currentPromptChunk) {
			currentPromptChunk.top += oldTop - newTop;
		}
	}

	function onPromptMouseMove({ clientX, clientY }) {
		promptOverlay.current.style.pointerEvents = 'auto';
		const elem = document.elementFromPoint(clientX, clientY);
		const pc = elem?.closest?.('[data-promptchunk]');
		const probs = elem?.closest?.('#probs');
		promptOverlay.current.style.pointerEvents = 'none';
		if (probs)
			return;
		if (!pc) {
			setCurrentPromptChunk(undefined);
			return;
		}
		const rect = [...pc.getClientRects()].at(-1);
		const index = +pc.dataset.promptchunk;
		const top = rect.top;
		const left = rect.x + rect.width / 2;
		setCurrentPromptChunk(cur => {
			const isCurrent = cur && cur.index === index && cur.top === top && cur.left === left;
			if (!isCurrent || !showProbs) {
				setShowProbs(false);
				clearTimeout(probsDelayTimer.current);
				probsDelayTimer.current = setTimeout(() => setShowProbs(true), 300);
			}
			return isCurrent ? cur : { index, top, left };
		});
	}

	async function switchCompletion(i, tok) {
		const newPrompt = [
			...promptChunks.slice(0, i),
			{
				...promptChunks[i],
				content: tok,
			},
		];
		setPromptChunks(newPrompt);
		predict(joinPrompt(newPrompt), newPrompt.length);
	}

	function switchEndpointAPI(value) {
		let url;
		try {
			url = new URL(endpoint);
		} catch {
			return;
		}
		switch (value) {
			case 0: // llama.cpp
				if (url.protocol != 'http:' && url.protocol != 'https:')
					url.protocol = "http:";
				url.port = 8080;
				break;
			case 1: // oobabooga
				if (url.protocol != 'ws:' && url.protocol != 'wss:')
					url.protocol = "ws:";
				url.port = 5005;
				break;
			case 2: // koboldcpp
				if (url.protocol != 'http:' && url.protocol != 'https:')
					url.protocol = "http:";
				url.port = 5001;
				break;
			case 3:
				if (url.protocol != 'http:' && url.protocol != 'https:')
					url.protocol = "http:";
				break;
		}
		setEndpoint(url.toString());
		setEndpointAPI(value);
	}

	function isMixedContent() {
		const isHttps = window.location.protocol == 'https:';
		let url;
		try {
			url = new URL(endpoint);
		} catch {
			return false;
		}
		return isHttps && (url.protocol !== 'https:' && url.protocol !== 'wss:');
	}

	function switchDarkMode(value, force) {
		if (value) {
			document.documentElement.classList.add('dark-mode');
		} else {
			document.documentElement.classList.remove('dark-mode');
		}
		if (!force)
			setDarkMode(value);
	}

	function sessionChanged() {
		// TODO: Store the undo/redo in the session.
		redoStack.current = [];
		undoStack.current = [];
		setUndoHovered(false);
	}

	const probs = useMemo(() =>
		showProbs && promptChunks[currentPromptChunk?.index]?.completion_probabilities?.[0]?.probs,
		[promptChunks, currentPromptChunk, showProbs]);

	return html`
		<div id="prompt-container" onMouseMove=${onPromptMouseMove}>
			<textarea
				ref=${promptArea}
				readOnly=${!!cancel}
				id="prompt-area"
				onInput=${onInput}
				onScroll=${onScroll}/>
			<div ref=${promptOverlay} id="prompt-overlay">
				${promptChunks.map((chunk, i) => {
					const isCurrent = currentPromptChunk && currentPromptChunk.index === i;
					const isNextUndo = undoHovered && !!undoStack.current.length && undoStack.current.at(-1) <= i;
					return html`
						<span
							key=${i}
							data-promptchunk=${i}
							className=${`${chunk.type === 'user' ? 'user' : 'machine'} ${isCurrent ? 'current' : ''} ${isNextUndo ? 'erase' : ''}`}>
							${(chunk.content === '\n' ? ' \n' : chunk.content) + (i === promptChunks.length - 1 && chunk.content.endsWith('\n') ? '\u00a0' : '')}
						</span>`;
				})}
			</div>
		</div>
		${probs ? html`
			<div
				id="probs"
				style=${{
					'display': 'none'
				}}>
				${probs.map((prob, i) =>
					html`<button key=${i} onClick=${() => switchCompletion(currentPromptChunk?.index, prob.tok_str)}>
						<div className="tok">${replaceUnprintableBytes(prob.tok_str)}</div>
						<div className="prob">${(prob.prob * 100).toFixed(2)}%</div>
					</button>`)}
			</div>` : null}
		<div id="sidebar">
			<${Checkbox} label="Dark Mode"
				value=${darkMode} onValueChange=${() => switchDarkMode(!darkMode, false)}/>
			<${CollapsibleGroup} label="Sessions">
				<${Sessions} sessionStorage=${sessionStorage}
					disabled=${!!cancel}
					onSessionChange=${sessionChanged}/>
			</${CollapsibleGroup}>
			<${CollapsibleGroup} label="Presets" expanded>
				<${InputBox} label="Server"
					className="${isMixedContent() ? 'mixed-content' : ''}"
					tooltip="${isMixedContent() ? 'This URL might be blocked due to mixed content. If the prediction fails, download mikupad.html and run it locally.' : ''}"
					readOnly=${!!cancel}
					value=${endpoint}
					onValueChange=${setEndpoint}/>
				<${SelectBox}
					label="API"
					disabled=${!!cancel}
					value=${endpointAPI}
					onValueChange=${switchEndpointAPI}
					options=${[
						{ name: 'llama.cpp', value: 0 },
						{ name: 'oobabooga', value: 1 },
						{ name: 'koboldcpp', value: 2 },
						{ name: 'openai', value: 3 },
					]}/>
				${endpointAPI == 3 && html`
					<${InputBox} label="API Key"
						readOnly=${!!cancel}
						value=${endpointAPIKey}
						onValueChange=${setEndpointAPIKey}/>
					<${InputBox} label="Model"
						datalist=${openaiModels}
						readOnly=${!!cancel}
						value=${endpointModel}
						onValueChange=${setEndpointModel}/>
					<${Checkbox} label="Full OpenAI compliance"
						disabled=${!!cancel} value=${openaiPresets} onValueChange=${setOpenaiPresets}/>`}
				<${InputBox} label="Seed (-1 = random)" type="text" inputmode="numeric"
					readOnly=${!!cancel} value=${seed} onValueChange=${setSeed}/>
				<${InputBox} label="Max Predict Tokens${endpointAPI != 0 ? ' (-1 = 1024)' : ' (-1 = infinite)'}" type="text" inputmode="numeric"
					readOnly=${!!cancel} value=${maxPredictTokens} onValueChange=${setMaxPredictTokens}/>
				<${InputBox} label="Temperature" type="number" step="0.01"
					readOnly=${!!cancel} value=${temperature} onValueChange=${setTemperature}/>
				${(!openaiPresets || endpointAPI != 3) && html`
					<div className="hbox">
						<${InputBox} label="Repeat penalty" type="number" step="0.01"
							readOnly=${!!cancel} value=${repeatPenalty} onValueChange=${setRepeatPenalty}/>
						<${InputBox} label="Repeat last n" type="number" step="1"
							readOnly=${!!cancel} value=${repeatLastN} onValueChange=${setRepeatLastN}/>
					</div>`}
				${(endpointAPI == 0 || !openaiPresets || endpointAPI == 3) && html`
					${(!openaiPresets || endpointAPI != 3) && html`
						<${Checkbox} label="Penalize NL"
							disabled=${!!cancel} value=${penalizeNl} onValueChange=${setPenalizeNl}/>`}
					<div className="hbox">
						<${InputBox} label="Presence penalty" type="number" step="0.01"
							readOnly=${!!cancel} value=${presencePenalty} onValueChange=${setPresencePenalty}/>
						<${InputBox} label="Frequency penalty" type="number" step="1"
							readOnly=${!!cancel} value=${frequencyPenalty} onValueChange=${setFrequencyPenalty}/>
					</div>`}
				${temperature <= 0 ? null : html`
					<${SelectBox}
						label="Mirostat"
						disabled=${!!cancel}
						value=${mirostat}
						onValueChange=${setMirostat}
						options=${[
							{ name: 'Off', value: 0 },
							{ name: 'Mirostat', value: 1 },
							{ name: 'Mirostat 2.0', value: 2 },
						]}/>
					${mirostat ? html`
						<div className="hbox">
							<${InputBox} label="Mirostat τ" type="number" step="0.01"
								readOnly=${!!cancel} value=${mirostatTau} onValueChange=${setMirostatTau}/>
							<${InputBox} label="Mirostat η" type="number" step="0.01"
								readOnly=${!!cancel} value=${mirostatEta} onValueChange=${setMirostatEta}/>
						</div>
					` : html`
						<div className="hbox">
							${(!openaiPresets || endpointAPI != 3) && html`
								<${InputBox} label="Top K" type="number" step="1"
									readOnly=${!!cancel} value=${topK} onValueChange=${setTopK}/>`}
							<${InputBox} label="Top P" type="number" step="0.01"
								readOnly=${!!cancel} value=${topP} onValueChange=${setTopP}/>
						</div>
						${(!openaiPresets || endpointAPI != 3) && html`
							<div className="hbox">
								<${InputBox} label="Typical p" type="number" step="0.01"
									readOnly=${!!cancel} value=${typicalP} onValueChange=${setTypicalP}/>
								<${InputBox} label="Tail Free Sampling z" type="number" step="0.01"
									readOnly=${!!cancel} value=${tfsZ} onValueChange=${setTfsZ}/>
							</div>
							<div className="hbox">
								<${InputBox} label="Min P" type="number" step="0.01"
									readOnly=${!!cancel} value=${minP} onValueChange=${setMinP}/>
							</div>`}
					`}
				`}
				${(!openaiPresets || endpointAPI != 3) && html`
					<${Checkbox} label="Ignore <eos>"
						disabled=${!!cancel} value=${ignoreEos} onValueChange=${setIgnoreEos}/>`}
			</${CollapsibleGroup}>
			${!!tokens && html`
				<${InputBox} label="Tokens" value=${tokens} readOnly/>`}
			<div className="buttons">
				<button
					className=${cancel ? (predictStartTokens === tokens ? 'processing' : 'completing') : ''}
					disabled=${!!cancel}
					onClick=${() => predict()}>
					Predict
				</button>
				<button disabled=${!cancel} onClick=${cancel}>Cancel</button>
				<div className="shorts">
					${!cancel && (!!undoStack.current.length || !!redoStack.current.length) && html`
						<button
							disabled=${!undoStack.current.length}
							onClick=${() => undo()}
							onMouseEnter=${() => setUndoHovered(true)}
							onMouseLeave=${() => setUndoHovered(false)}>
							<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24"><path d="M17.026 22.957c10.957-11.421-2.326-20.865-10.384-13.309l2.464 2.352h-9.106v-8.947l2.232 2.229c14.794-13.203 31.51 7.051 14.794 17.675z" fill="var(--color-light)"/></svg>
						</button>`}
					${!cancel && (!!undoStack.current.length || !!redoStack.current.length) && html`
						<button
							disabled=${!redoStack.current.length}
							onClick=${() => redo()}>
							<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24"><path d="M6.974 22.957c-10.957-11.421 2.326-20.865 10.384-13.309l-2.464 2.352h9.106v-8.947l-2.232 2.229c-14.794-13.203-31.51 7.051-14.794 17.675z" fill="var(--color-light)"/></svg>
						</button>`}
				</div>
			</div>
			${!!lastError && html`
				<span className="error-text">${lastError}</span>`}
		</div>`;
}

createRoot(document.body).render(html`<${App}/>`);

</script>
