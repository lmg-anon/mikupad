<!doctype html>
<meta charset="utf-8">
<!-- mikupad by Anon
  --
  -- To the extent possible under law, the person who associated CC0 with
  -- mikupad has waived all copyright and related or neighboring rights
  -- to mikupad.
  --
  -- You should have received a copy of the CC0 legalcode along with this
  -- work.  If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.
  -->
<title>mikupad</title>
<script type="importmap">
{
	"imports": {
		"react": "https://esm.sh/react@18",
		"react-dom/client": "https://esm.sh/react-dom@18/client?external=react",
		"htm/react": "https://esm.sh/htm@3/react?external=react&react=18",
		"scrollview-resize": "https://esm.sh/scrollview-resize@1.0.2"
	}
}
</script>
<style>

html {
	--color-miku: #009bb3;
	--color-base-0: oklch(0.20 0.02 60);
	--color-base-10: color-mix(in oklch, var(--color-base-100) 10%, var(--color-base-0));
	--color-base-20: color-mix(in oklch, var(--color-base-100) 20%, var(--color-base-0));
	--color-base-30: color-mix(in oklch, var(--color-base-100) 30%, var(--color-base-0));
	--color-base-40: color-mix(in oklch, var(--color-base-100) 40%, var(--color-base-0));
	--color-base-50: color-mix(in oklch, var(--color-base-100) 50%, var(--color-base-0));
	--color-base-60: color-mix(in oklch, var(--color-base-100) 60%, var(--color-base-0));
	--color-base-70: color-mix(in oklch, var(--color-base-100) 70%, var(--color-base-0));
	--color-base-80: color-mix(in oklch, var(--color-base-100) 80%, var(--color-base-0));
	--color-base-90: color-mix(in oklch, var(--color-base-100) 90%, var(--color-base-0));
	--color-base-100: oklch(0.95 0.04 70);
	--color-dark: var(--color-base-0);
	--color-light: var(--color-base-100);

	font-family: serif;
	font-size: 16px;
	min-height: 100%;
	display: flex;
	flex-direction: column;

	accent-color: var(--color-base-30);
	background: var(--color-base-20);
	color: var(--color-base-0);
}

html.serif-dark {
	--color-base-0: oklch(0.95 0.04 30);
	--color-base-10: color-mix(in oklch, var(--color-base-100) 10%, var(--color-base-0));
	--color-base-20: color-mix(in oklch, var(--color-base-100) 80%, var(--color-base-0));
	--color-base-30: color-mix(in oklch, var(--color-base-100) 70%, var(--color-base-0));
	--color-base-40: color-mix(in oklch, var(--color-base-100) 60%, var(--color-base-0));
	--color-base-50: color-mix(in oklch, var(--color-base-100) 50%, var(--color-base-0));
	--color-base-60: color-mix(in oklch, var(--color-base-100) 40%, var(--color-base-0));
	--color-base-70: color-mix(in oklch, var(--color-base-100) 30%, var(--color-base-0));
	--color-base-80: color-mix(in oklch, var(--color-base-100) 20%, var(--color-base-0));
	--color-base-90: color-mix(in oklch, var(--color-base-100) 10%, var(--color-base-0));
	--color-base-100: oklch(0.20 0.02 30);
	--color-dark: var(--color-base-100);
	--color-light: var(--color-base-0);

	color-scheme: dark;
}

html.nockoffAI {
	---color-bg-dark: #191b31;
	--color-bg: #191b31;

	--color-text: #fff;
	--color-base-0: #fff;
	--color-base-10: color-mix(in oklch, var(--color-base-100) 90%, var(--color-base-0));
	--color-base-20: color-mix(in oklch, var(--color-base-100) 80%, var(--color-base-0));
	--color-base-30: color-mix(in oklch, var(--color-base-100) 70%, var(--color-base-0));
	--color-base-40: color-mix(in oklch, var(--color-base-100) 60%, var(--color-base-0));
	--color-base-50: color-mix(in oklch, var(--color-base-100) 50%, var(--color-base-0));
	--color-base-60: color-mix(in oklch, var(--color-base-100) 40%, var(--color-base-0));
	--color-base-70: color-mix(in oklch, var(--color-base-100) 30%, var(--color-base-0));
	--color-base-80: color-mix(in oklch, var(--color-base-100) 20%, var(--color-base-0));
	--color-base-90: color-mix(in oklch, var(--color-base-100) 10%, var(--color-base-0));
	--color-base-100: #13152c;
	--color-dark: var(--color-base-100);
	--color-light: #fff;
	--color-input: #0e0f21;
	--color-sidebar: var(--color-base-100);
	--color-prompt-area: #191b31;
	--color-hover: #13152c;
	--color-button: #22253f;
	--color-disabled: #161833;
	--color-button-hover: #282b44;

	--token-prob-box: #4a4a4a;

	font-family: "Source Sans Pro", "Helvetica Neue", sans-serif;
	font-size: 15.5px;

	accent-color: var(--color-base-30);
	background: var(--color-bg-dark);
	color: var(--color-base-0);
	color-scheme: dark;
}
html.nockoffAI body {
	background: var(--color-prompt-area)
}

html.monospace-dark {
	---color-bg-dark: #282833;
	--color-bg: #202020;
	--color-text: #bababa;
	--color-base-0: oklch(77.65% 0.0752 285.22);
	--color-base-10: color-mix(in oklch, var(--color-base-100) 90%, var(--color-base-0));
	--color-base-20: color-mix(in oklch, var(--color-base-100) 80%, var(--color-base-0));
	--color-base-30: color-mix(in oklch, var(--color-base-100) 70%, var(--color-base-0));
	--color-base-40: color-mix(in oklch, var(--color-base-100) 60%, var(--color-base-0));
	--color-base-50: color-mix(in oklch, var(--color-base-100) 50%, var(--color-base-0));
	--color-base-60: color-mix(in oklch, var(--color-base-100) 40%, var(--color-base-0));
	--color-base-70: color-mix(in oklch, var(--color-base-100) 30%, var(--color-base-0));
	--color-base-80: color-mix(in oklch, var(--color-base-100) 20%, var(--color-base-0));
	--color-base-90: color-mix(in oklch, var(--color-base-100) 10%, var(--color-base-0));
	--color-base-100: oklch(24.28% 0.015 285.22);
	--color-dark: var(--color-base-100);
	--color-light: var(--color-base-0);
	--token-prob-box: #4a4a4a;

	font-family: monospace;
	font-size: 15px;

	accent-color: var(--color-base-30);
	background: var(--color-bg-dark);
	color: var(--color-base-0);
	color-scheme: dark;
}

body {
	margin: 0;
	display: flex;
	flex: auto;
	flex-direction: row;
}
@media (min-width: calc(40.5em + 250px)) {
	body.attachSidebar {
		margin-right: auto;
		margin-left: auto;
	}
}

#prompt-container {
	position: relative;
	font-size: 1.125rem;
	max-width: 36em;
	margin-right: auto;
	margin-left: auto;
	flex: 1;
	display: flex;
	flex-direction: column;
}
@media (min-width: calc(40.5em + 250px)) {
	body.attachSidebar #prompt-container {
		min-width: 36em;
		max-width: 36em;
	}
}

#prompt-area, #prompt-overlay {
	flex: 1;
	border: none;
	outline: none;
	resize: none;
	background: var(--color-base-100);
	color: var(--color-base-10);
	padding: 2em 3em;
	margin: 0;
	scrollbar-gutter: stable;
	font: inherit;
	box-sizing: content-box;
	text-size-adjust: 100%;
	-webkit-text-size-adjust: 100%;
	-moz-text-size-adjust: 100%;
	/*white-space: break-spaces;*/
	word-wrap: break-word;
}
html.monospace-dark #prompt-area,
html.monospace-dark #memory-area,
html.monospace-dark #an-area,
html.monospace-dark .expanded-text-area-settings,
html.monospace-dark .wi-textarea {
	background: var(--color-bg);
	color: var(--color-text);
}
html.nockoffAI #prompt-area {
	text-indent: 1em each-line;
	background: var(--color-prompt-area);
	color: var(--color-text);
}
html.nockoffAI #prompt-overlay {
	text-indent: 1em each-line;
}
html.nockoffAI #memory-area,
html.nockoffAI #an-area,
html.nockoffAI .expanded-text-area-settings,
html.nockoffAI .wi-textarea {
	background: var(--color-input);
	color: var(--color-text);
}
.modal .wi-textarea {
	resize:vertical;
	background: var(--color-base-100);
	color: var(--color-base-10);
}

#memory-area, #an-area, .expanded-text-area-settings, .wi-textarea {
	flex: 1;
	border: none;
	outline: none;
	resize: none;
	background: var(--color-base-100);
	color: var(--color-base-10);
	padding: 0.5em;
	scrollbar-gutter: stable;
	font-family: inherit;
	border-radius: 2px;
}
#memory-area {
	min-height:9.5em;
}
#an-area {
	min-height:3.5em;
}
.wi-textarea {
	min-height: 4em;
}

#advancedContextPlaceholders {
	background: var(--color-base-30);
	margin: 1em auto;
	padding: .25em;
	border-radius: 2px;
	width: fit-content;
}
#advancedContextPlaceholders table {
	border-color: var(--color-base-80);
}
#advancedContextPlaceholders th,
#advancedContextPlaceholders td {
	text-align: center;
	padding: 0.15em;
}
#advancedContextPlaceholders td {
	user-select:all;
}

#advanced-context-order-settings {
	min-height: 3.5em;
}

.expanded-text-area-settings {
	margin: 8px 0 8px 0;
	width:100%;
	box-sizing: border-box;
	height:25.5em;
}

#prompt-overlay {
	white-space: pre-wrap;
	position: absolute;
	left: 0;
	top: 0;
	right: 0;
	bottom: 0;
	transform: translate(0px, 0px);
	background: transparent;
	color: transparent;
	pointer-events: none;
	user-select: none;
	-ms-user-select: none;
	-webkit-user-select: none;
	overflow: hidden;
}

#prompt-container:hover #prompt-overlay > .machine {
	background: color-mix(in srgb, var(--color-miku) 10%, transparent);
}
#prompt-container #prompt-overlay > .machine.erase {
	background: color-mix(in srgb, #FF0000 10%, transparent);
}
#prompt-container #prompt-overlay > .machine.current {
	border-radius: 3px;
	outline: 1px solid var(--color-base-50);
	outline-offset: 1px;
}

#probs {
	position: absolute;
	background: var(--color-base-30);
	top: var(--probs-top);
	left: var(--probs-left);
	display: flex;
	transform: translate(-50%, -100%);
	border-radius: 5px;
	box-shadow: 0 1px 1px 1px #00000033;
	z-index: 9999;
}
html.monospace-dark #probs,
html.nockoffAI #probs {
	background: var(--color-base-10);
	border: 1px solid var(--token-prob-box);
	border-radius: 4px;
	box-shadow: none;
}
#probs > button {
	cursor: pointer;
	background: transparent;
	color: var(--color-light);
	border-radius: 0;
	padding: 4px 8px;
	display: flex;
	flex-direction: column;
	flex: none;
	font-size: 1rem;
}
#probs > button:first-child {
	border-radius: 5px 0 0 5px;
	padding-left: 6px;
}
#probs > button:last-child {
	border-radius: 0 5px 5px 0;
	padding-right: 6px;
}
#probs > button:hover {
	background: var(--color-base-40);
}
#probs > button:active {
	background: var(--color-base-50);
}
#probs > button > .prob {
	font-size: 0.8rem;
}

.modal-overlay {
	position: fixed;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
	background: rgba(0, 0, 0, 0.65);
	display: flex;
	align-items: center;
	justify-content: center;
}
.modal-container {
	width: 100%;
	height: 100%;
	display: flex;
	align-items: center;
	justify-content: center;
}

.modal {
	color: var(--color-light);
	position: relative;
	background: var(--color-base-50);
	width: 75%;
	max-height: 80vh;
	padding: 1em;
	border-radius: 5px;
	display: flex;
	flex-direction: column;
}
html.monospace-dark .modal {
	background: #282833;
}
html.nockoffAI .modal {
	background: var(--color-sidebar);
	color:var(--color-base-50);
}
html.nockoffAI .modal-title {
	color:var(--color-text);
}
html.nockoffAI  #context-order-desc,
html.nockoffAI  #contextTokensTable,
html.nockoffAI .modal-desc {
	color:var(--color-base-80);
}

.button-modal-top {
	all:unset;
	position: absolute;
	top:1em;
	right:1em;
	width:1.25em;
	height:1.25em;
	border-radius: 3px;
}
.modal-title {
	font-size: 150%;
	font-weight:bold;
	margin-bottom: .25em;
}

.modal-content {
	overflow: hidden;
}

hr {
	border:unset;
	border-top: 1px solid var(--color-base-40);
	margin: 0.75em -1em 0.5em;
}


/* world info */

.modal-wi-content {
	display: flex;
	flex-direction:column;
	margin-top:0.5em;
	max-height:50vh;
}

#modal-wi-global{
	display: flex;
	flex-direction: column;
	gap: 4px;
}

#button-wi-new {
	width: 100%;
}

.wi-entry {
	margin: 4px 0;
}

.wi-entry-controls {
	display: grid;
	grid-template-columns: min-content 1fr;
	grid-template-rows: min-content 1fr;
	border-top: 1px solid var(--color-base-40);
	padding-top: 8px;
	grid-template-areas:
	  "wi-entry-filler wi-entry-name ."
	  "wi-entry-buttons wi-entry-text ."
}
.wi-entry-filler { grid-area: wi-entry-filler; }
.wi-entry-name {
	grid-area: wi-entry-name;
	margin-bottom:8px;
}
.wi-entry-name input {
	background: var(--color-base-60);
	font-weight:bold !important;
	font-size: 1.2rem !important;
}
html.nockoffAI .wi-entry-name input {
	background: var(--color-base-10) !important;
}

.wi-entry-buttons {
	grid-area: wi-entry-buttons;
	margin-right: 4px; /* because gap sucks */
	display: flex;
	align-items: center;
	justify-content: center;
}
.wi-entry-buttons-container {
	display: flex;
	flex-direction: column;
	justify-content: space-between;
	height: 5em;
}
.wi-entry-buttons button {
	display: grid;
	width:2em;
	height:fit-content;
}

.wi-entry-text {
	grid-area: wi-entry-text;
}
.wi-entry-text .hbox {
	grid-area: wi-entry-text;
	margin-bottom:4px;
}

.symbol-button {
	position: relative;
	margin-top: auto;
	width: 2.182rem;
	height: 1.625rem;
}
.symbol-button > svg {
	position: absolute;
	top: 50%;
	left: 50%;
	transform: translate(-50%, -50%);
} 

/* logit bias */
.hbox-button {
	margin-top: auto;
	width: 1.625rem;
}
.hbox-flex {
	display: flex;
	flex-direction: row;
	gap: 8px;
}
.hbox-flex > .InputBox {
  width: 100%;
}
.small-inputBox {
	width: 8em;
}
.logitBiasContainer {
	position: relative;
	flex-wrap: unset !important;
}
.logitBiasPower-sidebar {
	width:10ch !important;
} 


.overflow-container {
	overflow-y:auto;
}
#logitBiasPower {
	text-align: center;
}

.lb-modal-grid-column {
	display: grid;
	grid-auto-rows: min-content;
	gap: 8px;
	max-height: 40vh;
	padding-right: .75em;

}
.lb-modal-grid-row  {
	display: grid;
	grid-template-columns: 4em 1fr min-content;
	grid-template-rows: min-content min-content min-content;
	gap: 1px 8px;
	grid-template-areas: 
		"power input add"
		". tokens remove"
		"hr hr hr"; 
	padding: 1px;
}
.lb-modal-power {
	grid-area: power;
	text-align: center;
}
.lb-modal-input { 
	grid-area: input;
	text-align: left;
}
.lb-modal-button.lb-modal-button-add { 
	grid-area: add;
}
.lb-modal-button.lb-modal-button-remove { 
	grid-area: remove;
}
.lb-modal-tokenized { 
	grid-area: tokens;
	font-family: monospace;
	font-size:0.7rem;
	margin-top: auto;
	display: grid;
	align-content: center;
	margin: auto 0 auto 0;
	/* height: 1.625rem; */
	width: 100%;
	overflow-wrap: anywhere;
}
.lb-modal-biasList hr {
	grid-area: hr;
	width: 90%;
	margin: 4px auto auto auto;
}

.lb-modal-biasList {
	display: grid;
	grid-template-columns: 1fr 1fr;
	gap: 8px;
}

#instructmodal-name {
	size:110%;
}
.instructmodal-edits .hbox {
	margin-top:8px;
}




#sidebar {
	font-family: inherit;
	width: 250px;
	background: var(--color-base-50);
	color: var(--color-light);
	padding: 4px 8px;
	display: flex;
	flex-direction: column;
	gap: 4px;
	overflow: auto;
	max-height: calc(100vh - 8px);
}
html.monospace-dark #sidebar {
	background: #282833;
	width: 265px;
}
html.nockoffAI #sidebar {
	background: var(--color-sidebar);
	color: var(--color-base-50);
	width: 255px;
}

.flex1 {
	flex: 1;
}

.hbox {
	flex: none;
	display: grid;
	grid: auto / auto-flow minmax(min-content, 1fr);
	gap: 8px;
}
.hbox-flex {
	display: flex;
	flex-wrap: wrap;
	gap: 8px;
}

.vbox {
	flex: none;
	display: grid;
	grid: auto / minmax(min-content, 1fr) auto-flow;
	grid-template-rows: 0fr 0fr 0fr 0fr;
	gap: 4px;
}

.InputBox, .SelectBox, .TextArea {
	display: flex;
	position: relative;
	flex-direction: column;
	font-size: 0.75rem;
	padding: 0 8px;
}
.InputBox > div > input, .SelectBox > select, .TextArea > textarea {
	appearance: none;
	border: none;
	outline: none;
	width: 100%;
	box-sizing: content-box;
	font: inherit;
	font-size: 1rem;
	padding: 4px 8px;
	margin: 0 -8px;
	border-radius: 2px;
	color: inherit;
	background: var(--color-base-30);
	flex: none;
}

html.monospace-dark .InputBox > div > input, html.monospace-dark .SelectBox > select,
html.nockoffAI .InputBox > div > input, html.nockoffAI .SelectBox > select {
	color: var(--color-light);
}

.InputBox > div > input:read-only {
	background: var(--color-base-60);
}
html.monospace-dark .InputBox > div > input:read-only {
	background: var(--color-base-30);
}
html.nockoffAI .InputBox > div > input:read-only {
	background: var(--color-disabled);
}
html.nockoffAI .SelectBox > select,
html.nockoffAI .collapsible-header,
html.nockoffAI .InputBox > div > input {
	background: var(--color-input);
}
html.nockoffAI .horz-separator {
	border-top: 3px dotted color-mix(in oklch, var(--color-base-100) 90%, var(--color-light));
}

.InputBox > div > input:focus-visible {
	outline: 1px solid var(--color-base-0);
}
.SelectBox > select:disabled {
	background: var(--color-base-60);
}
html.nockoffAI .SelectBox > select:disabled {
	background: var(--color-disabled);
}
.relative {
	position: relative;
}

.Checkbox {
	user-select: none;
	margin: 0 5px 0 0;
	vertical-align: middle;
	position: relative;
  	bottom: .08em;
}

.InputBox > div > input.mixed-content {
	outline: 1px solid yellow;
}
.InputBox > div > input.rejected {
	outline: 1px solid #ff3131;
}

.InputBox > div > button {
	margin-left: 4px;
	padding: 4px;
	line-height: 0;
	margin-right: -8px;
}

.tooltip {
	position: relative;
}
.tooltip .tooltiptext {
	white-space: pre-wrap;
	pointer-events: none;
	width: 95%;
	background-color: #000000AA;
	color: var(--color-light);
	text-align: center;
	padding: 5px 4px;
	margin: 0 -8px;
	border-radius: 6px;
	opacity: 0;
	transition: opacity 0.3s;

	position: absolute;
	z-index: 1;
	transform: translate(0, -75%);
}
html.monospace-dark .tooltip .tooltiptext {
	transform: translate(0, -65%);
}
.tooltip .tooltiptext.short {
	transform: translate(0, -45%);
}
html.monospace-dark .tooltip .tooltiptext.short {
	transform: translate(0, -65%);
}
.tooltip:hover .tooltiptext {
	opacity: 1;
}

.error-text {
	width: max-content;
	text-align: center;
	background: #4E3534;
	border-radius: 4px;
	color: #FF8080;
	margin-left: auto;
	margin-right: auto;
	padding: 2px 10px;
}

button {
	appearance: none;
	border: none;
	outline: none;
	font: inherit;
	padding: 4px 8px;
	color: inherit;
	background: var(--color-base-30);
	border-radius: 2px;
}
html.nockoffAI button {
	background: var(--color-button);
	color: var(--color-base-90);
}
html.nockoffAI .Session button:not(:hover),
html.nockoffAI button.textAreaSettings:not(:hover) {
	background: none;
}
button.textAreaSettings {
	all: unset;
	color: var(--color-base-50);
	width:1.25em;
	position:absolute;
	top:calc(1.25em + 1px);
	right:1px;
}
button.textAreaSettings.textAreaSettings-bias {
	top: 1.45em;
	right: 5px;
}
.token-counter {
	pointer-events: none;
	position:absolute;
	bottom:0;
	right:0;
	transform: translate(0%,-50%);
	color: var(--color-base-50);
	background: color-mix(in srgb, var(--color-base-30), transparent 50%);
}.token-counter::after {
	content:" Tokens";
}
button:hover {
	background: var(--color-base-40);
}
html.nockoffAI button:hover {
	background: var(--color-button-hover);
}
button:active {
	background: var(--color-base-50);
}
button:disabled {
	background: var(--color-base-60);
}
html.nockoffAI button:disabled {
	background: var(--color-disabled);
}
button:focus-visible {
	outline: 1px solid var(--color-base-0);
}
button.processing {
	outline: 1px solid rgba(255, 255, 255, 0.5);
	animation: .5s ease-out infinite alternate processing;
}
@keyframes processing {
	from { outline-width: 0px; }
	to { outline-width: 4px; }
}
button.completing {
	outline: 1px solid limegreen;
	animation: .5s ease-out infinite alternate completing;
}
@keyframes completing {
	from { outline-width: 0px; }
	to { outline-width: 4px; }
}

.buttons {
	display: flex;
	gap: 8px;
	justify-content: center;
}
.buttons .shorts {
	line-height: 0;
}
.buttons .shorts > button {
	height: 100%;
}

.instructTemplatesImportExport{
	width: fit-content;
	margin: auto;
	display: flex;
	gap: 8px;
}
.instructTemplateSidebar > .SelectBox {
	width: 100%;
}
.instructTemplateSidebar > .hbox-button {
	min-width: max-content;
}

.collapsible-group {
	border: none;
	outline: none;
}

.collapsible-header {
	user-select: none;
	cursor: pointer;
	display: flex;
	align-items: center;
	padding: 4px 8px;
	color: inherit;
	background-color: var(--color-base-30);
	border-radius: 2px;
}
.collapsible-header svg {
	margin-right: 5px;
}

.collapsible-content {
	transform: scaleY(0);
	transition: transform 0.15s ease-in-out 0s, max-height 0.15s ease-in-out 0s;
	transform-origin: center top;
	display: flex;
	flex-direction: column;
	gap: 4px;
}
.collapsible-content.expanded {
	transform: scaleY(1);
	margin-top: 4px;
}

.Sessions {
	display: flex;
	flex: auto;
	flex-direction: row;
	gap: 4px;
}
.Sessions > ul {
	list-style-type: none;
	margin: 0;
	padding: 0;
	max-height: 200px;
	overflow-y: auto;
	width: 100%;
	background: var(--color-base-40);
}
html.monospace-dark .Sessions > ul {
	background: var(--color-base-20);
}
html.nockoffAI .Sessions > ul {
	background: var(--color-input);
}
.Sessions.disabled > ul {
	background: var(--color-base-50);
	pointer-events: auto;
}
html.nockoffAI .Sessions.disabled > ul {
	background: var(--color-disabled);
}

.Sessions > ul > li {
	display: flex;
	align-items: center;
}
.Sessions.disabled > ul > li {
	pointer-events: none;
}

.Session {
	width: 100%;
	padding: 0.5rem;
	padding-left: 0.8rem;
	cursor: pointer;
	display: flex;
	word-break: break-word;
	user-select: none;
}
html.nockoffAI .Session {
	margin: 0.25rem;
	padding: 0.25rem;
	color: var(--color-base-70);
}
html.nockoffAI .Session > input {
	background-color: var(--color-input);
	outline: none;
}
html.nockoffAI .Session.selected {
	color: var(--color-text);
	background-color: var(--color-prompt-area)
}
.Session:hover {
	background-color: var(--color-base-60);
}
html.monospace-dark .Session:hover {
	background-color: var(--color-base-40);
}
html.nockoffAI .Session:hover {
	background-color: var(--color-hover);
}
.Session.selected {
	background-color: var(--color-base-30);
}
html.monospace-dark .Session.selected {
	background-color: var(--color-base-10);
}

.Session > button {
	margin-left: 4px;
	padding: 0;
	background: none;
	border: none;
	cursor: pointer;
	outline: none;
	line-height: 0;
	opacity: 0.5;
}
.Session > button:hover {
	opacity: 1;
}

.Session > input {
	padding: 0;
	appearance: none;
	border: none;
	outline: 1px solid var(--color-light);
	background-color: var(--color-base-40);
	font: inherit;
	color: inherit;
	width: 80%;
	margin-right: 5%;
}

#error-bar {
	position: absolute;
	top: 0;
	left: 0;
	right: 0;
	min-height: 0;

	background-color: #4E3534;
	color: #FF8080;
	text-align: center;
	box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

#error-bar div {
	padding: 10px;
}

.flex-separator {
	margin-left: auto;
}

.horz-separator {
	border-top: 3px dotted var(--color-base-60);
}
html.monospace-dark .horz-separator {
	border-top: 3px dotted var(--color-base-20);
}

.eye-button {
	position: relative;
	margin-top: auto;
	width: 1.891rem;
	height: 1.625rem;
}
html.monospace-dark .eye-button {
	position: relative;
	margin-top: auto;
	width: 1.891rem;
	height: 1.725rem;
}
.eye-button > svg {
	position: absolute;
	top: 50%;
	left: 50%;
	transform: translate(-50%, -50%);
} 

</style>
<script type="module">

import { useEffect, useLayoutEffect, useMemo, useRef, useState } from 'react';
import { createRoot } from 'react-dom/client';
import { html } from 'htm/react';
import { SVResizeObserver } from 'scrollview-resize';

// Polyfill for piece of shit Chromium
if (!(Symbol.asyncIterator in ReadableStream.prototype)) {
	ReadableStream.prototype[Symbol.asyncIterator] = async function* () {
		const reader = this.getReader();
		try {
			for (;;) {
				const { done, value } = await reader.read();
				if (done)
					return;
				yield value;
			}
		} finally {
			reader.releaseLock();
		}
	};
}

function exportText(filename, text) {
	const textBlob = new Blob([text], {type: 'text/plain;charset=utf-8'});
	const textURL = URL.createObjectURL(textBlob);
	var element = document.createElement('a');
	element.setAttribute('href', textURL);
	element.setAttribute('download', filename);
	element.style.display = 'none';
	document.body.appendChild(element);
	element.click();
	URL.revokeObjectURL(textURL);
	document.body.removeChild(element);
}

function normalizeEndpoint(endpoint, endpointAPI) {
	const url = new URL(endpoint.trim());
	url.pathname = url.pathname.replace(/\/+/g, "/"); // normalize consecutive slashes

	let urlString = url.toString();
	if (endpointAPI == 3) // openai
		urlString = urlString.replace(/\/v1\/?$/, ""); // remove "/v1" from the end of the string
	if (endpointAPI == 2) // koboldcpp
		urlString = urlString.replace(/\/api\/?$/, ""); // remove "/api" from the end of the string
	urlString = urlString.replace(/\/$/, ""); // remove "/" from the end of the string

	return urlString;
}

export async function getTokenCount({ endpoint, endpointAPI, endpointAPIKey, signal, ...options }) {
	endpoint = normalizeEndpoint(endpoint, endpointAPI);
	switch (endpointAPI) {
		case 0: // llama.cpp
			return await llamaCppTokenCount({ endpoint, endpointAPIKey, signal, ...options });
		case 2: // koboldcpp
			return await koboldCppTokenCount({ endpoint, signal, ...options });
		case 3: // openai
			// These endpoints don't have a token count endpoint...
			if (new URL(endpoint).host === 'api.openai.com' || new URL(endpoint).host === 'api.together.xyz')
				return 0;

			// Each backend that exposes an OpenAI-compatible API may have a different token count endpoint.
			// Instead of asking the user which backend they are using, let's try each one.
			let tokenCount = 0;
			tokenCount = await openaiAphroditeTokenCount({ endpoint, endpointAPIKey, signal, ...options });
			if (tokenCount != -1)
				return tokenCount;
			tokenCount = await openaiOobaTokenCount({ endpoint, signal, ...options });
			if (tokenCount != -1)
				return tokenCount;
			tokenCount = await openaiTabbyTokenCount({ endpoint, endpointAPIKey, signal, ...options });
			if (tokenCount != -1)
				return tokenCount;
			return 0;
	}
}

export async function getTokens({ endpoint, endpointAPI, endpointAPIKey, signal, ...options }) {
	// currently only implemented for llama.cpp and koboldcpp
	// returns a json object in the format of:
	// { ids:[ array of token ids ], str:[ array of detokenized ids ] }
	// example: { ids:[9288,4731],str:["test"," string"] }
	endpoint = normalizeEndpoint(endpoint, endpointAPI);
	switch (endpointAPI) {
		case 0: // llama.cpp
			return await llamaCppTokenize({ endpoint, endpointAPIKey, signal, ...options });
		case 2: // koboldcpp
			return await koboldCppTokenize({ endpoint, signal, ...options });
		case 3: // openai
			return await openaiTokenize({ endpoint, endpointAPIKey, signal, ...options })
	}
}

export async function getModels({ endpoint, endpointAPI, endpointAPIKey, signal, ...options }) {
	endpoint = normalizeEndpoint(endpoint, endpointAPI);
	switch (endpointAPI) {
		case 3: // openai
			return await openaiModels({ endpoint, endpointAPIKey, signal, ...options });
		default:
			return [];
	}
}

export async function* completion({ endpoint, endpointAPI, endpointAPIKey, signal, ...options }) {
	endpoint = normalizeEndpoint(endpoint, endpointAPI);
	switch (endpointAPI) {
		case 0: // llama.cpp
			return yield* await llamaCppCompletion({ endpoint, endpointAPIKey, signal, ...options });
		case 2: // koboldcpp
			return yield* await koboldCppCompletion({ endpoint, signal, ...options });
		case 3: // openai
			return yield* await openaiCompletion({ endpoint, endpointAPIKey, signal, ...options });
	}
}

export async function abortCompletion({ endpoint, endpointAPI, ...options }) {
	endpoint = normalizeEndpoint(endpoint, endpointAPI);
	switch (endpointAPI) {
		case 2: // koboldcpp
			return await koboldCppAbortCompletion({ endpoint, ...options });
		case 3: // openai (ooba)
			return await openaiOobaAbortCompletion({ endpoint, ...options });
	}
}

// Function to parse text/event-stream data and yield JSON objects
async function* parseEventStream(eventStream) {
	let buf = '';
	let ignoreNextLf = false;

	for await (let chunk of eventStream.pipeThrough(new TextDecoderStream())) {
		// A CRLF could be split between chunks, so if the last chunk ended in
		// CR and this chunk started with LF, trim the LF
		if (ignoreNextLf && /^\n/.test(chunk)) {
			chunk = chunk.slice(1);
		}
		ignoreNextLf = /\r$/.test(chunk);

		// Event streams must be parsed line-by-line (ending in CR, LF, or CRLF)
		const lines = (buf + chunk).split(/\n|\r\n?/);
		buf = lines.pop();
		let type, data;

		for (const line of lines) {
			if (!line) {
				type = undefined;
				data = undefined;
				continue;
			}
			const { name, value } = /^(?<name>.*?)(?:: ?(?<value>.*))?$/s.exec(line).groups;
			switch (name) {
				case 'event':
					type = (value ?? '');
					break;
				case 'data':
					data = data === undefined ? (value ?? '') : `${data}\n${value}`;
					break;
			}
			// We only emit message-type events for now (and assume JSON)
			if (data && (type || 'message') === 'message') {
				if (data === '[DONE]') {
					// This is a hack because we aren't following exactly the spec...
					break;
				}
				const json = JSON.parse(data);
				// Both Chrome and Firefox suck at debugging
				// text/event-stream, so make it easier by logging events
				if (window.logSSEEvents) {
					console.log('event', json);
				}
				yield json;
				type = undefined;
				data = undefined;
			}
		}
	}
}

async function llamaCppTokenCount({ endpoint, endpointAPIKey, proxyEndpoint, signal, ...options }) {
	const res = await fetch(`${proxyEndpoint ?? endpoint}/tokenize`, {
		method: 'POST',
		headers: {
			'Content-Type': 'application/json',
			...(endpointAPIKey ? { 'Authorization': `Bearer ${endpointAPIKey}` } : {}),
			...(proxyEndpoint ? { 'X-Real-URL': endpoint } : {})
		},
		body: JSON.stringify(options),
		signal,
	});
	if (!res.ok)
		throw new Error(`HTTP ${res.status}`);
	const { tokens } = await res.json();
	return tokens.length + 1; // + 1 for BOS, I guess.
}

async function llamaCppTokenize({ endpoint, endpointAPIKey, proxyEndpoint, signal, ...options }) {
	const res = await fetch(`${proxyEndpoint ?? endpoint}/tokenize`, {
		method: 'POST',
		headers: {
			'Content-Type': 'application/json',
			...(endpointAPIKey ? { 'Authorization': `Bearer ${endpointAPIKey}` } : {}),
			...(proxyEndpoint ? { 'X-Real-URL': endpoint } : {})
		},
		body: JSON.stringify(options),
		signal,
	});
	if (!res.ok)
		throw new Error(`HTTP ${res.status}`);
	const { tokens } = await res.json();

	const strings = [];
	for (let i=0; i<tokens.length; i++) {
		const string = await llamaCppDetokenize({
				endpoint,
				endpointAPIKey,
				tokens: [ tokens[i] ],
				signal: signal,
		}); // maybe batch all tokens together with a bos token between them
			// something? that'd probably be more efficient. don't know how
			// to get the bos token ID though.
		strings.push(string);
	};
	return {ids:tokens,str:strings};
}
async function llamaCppDetokenize({ endpoint, endpointAPIKey, proxyEndpoint, signal, ...options }) {
	const res = await fetch(`${proxyEndpoint ?? endpoint}/detokenize`, {
		method: 'POST',
		headers: {
			'Content-Type': 'application/json',
			...(endpointAPIKey ? { 'Authorization': `Bearer ${endpointAPIKey}` } : {}),
			...(proxyEndpoint ? { 'X-Real-URL': endpoint } : {})
		},
		body: JSON.stringify(options),
		signal,
	});
	if (!res.ok)
		throw new Error(`HTTP ${res.status}`);
	const { content } = await res.json();
	return content
}

async function* llamaCppCompletion({ endpoint, endpointAPIKey, proxyEndpoint, signal, ...options }) {
	const res = await fetch(`${proxyEndpoint ?? endpoint}/completion`, {
		method: 'POST',
		headers: {
			'Content-Type': 'application/json',
			...(endpointAPIKey ? { 'Authorization': `Bearer ${endpointAPIKey}` } : {}),
			...(proxyEndpoint ? { 'X-Real-URL': endpoint } : {})
		},
		body: JSON.stringify({
			...options,
			stream: true,
			cache_prompt: true,
		}),
		signal,
	});
	if (!res.ok)
		throw new Error(`HTTP ${res.status}`);
	return yield* await parseEventStream(res.body);
}

async function koboldCppTokenCount({ endpoint, proxyEndpoint, signal, ...options }) {
	const res = await fetch(`${proxyEndpoint ?? endpoint}/api/extra/tokencount`, {
		method: 'POST',
		headers: {
			'Content-Type': 'application/json',
			...(proxyEndpoint ? { 'X-Real-URL': endpoint } : {})
		},
		body: JSON.stringify({
			prompt: options.content
		}),
		signal,
	});
	if (!res.ok)
		throw new Error(`HTTP ${res.status}`);
	const { value } = await res.json();
	return value;
}

async function koboldCppTokenize({ endpoint, proxyEndpoint, signal, ...options }) {
	const res = await fetch(`${proxyEndpoint ?? endpoint}/api/extra/tokencount`, {
		method: 'POST',
		headers: {
			'Content-Type': 'application/json',
			...(proxyEndpoint ? { 'X-Real-URL': endpoint } : {})
		},
		body: JSON.stringify({
			prompt: options.content
		}),
		signal,
	});
	if (!res.ok)
		throw new Error(`HTTP ${res.status}`);
	const { ids } = await res.json();
	ids.shift() // kobold automatically adds a token, so we need to remove it
	return {ids:ids,str:""};

}

function koboldCppConvertOptions(options) {
	const swapOption = (lhs, rhs) => {
		if (lhs in options) {
			options[rhs] = options[lhs];
			delete options[lhs];
		}
	};
	if (options.n_predict === -1) {
		options.n_predict = 1024;
	}
	swapOption("n_ctx", "max_context_length");
	swapOption("n_predict", "max_length");
	swapOption("repeat_penalty", "rep_pen");
	swapOption("repeat_last_n", "rep_pen_range");
	swapOption("tfs_z", "tfs");
	swapOption("typical_p", "typical");
	swapOption("seed", "sampler_seed");
	swapOption("stop", "stop_sequence");
	swapOption("ignore_eos", "use_default_badwordsids");
	return options;
}

async function* koboldCppCompletion({ endpoint, proxyEndpoint, signal, ...options }) {
	const res = await fetch(`${proxyEndpoint ?? endpoint}/api/extra/generate/stream`, {
		method: 'POST',
		headers: {
			'Content-Type': 'application/json',
			...(proxyEndpoint ? { 'X-Real-URL': endpoint } : {})
		},
		body: JSON.stringify({
			...koboldCppConvertOptions(options),
			stream: true,
		}),
		signal,
	});
	if (!res.ok)
		throw new Error(`HTTP ${res.status}`);
	for await (const chunk of parseEventStream(res.body)) {
		yield { content: chunk.token };
	}
}

async function koboldCppAbortCompletion({ endpoint, proxyEndpoint, ...options }) {
	try {
		await fetch(`${proxyEndpoint ?? endpoint}/api/extra/abort`, {
			method: 'POST',
			headers: {
				...(proxyEndpoint ? { 'X-Real-URL': endpoint } : {})
			},
		});
	} catch (e) {
		reportError(e);
	}
}

async function openaiAphroditeTokenCount({ endpoint, endpointAPIKey, proxyEndpoint, signal, ...options }) {
	try {
		const res = await fetch(`${proxyEndpoint ?? endpoint}/v1/token/encode`, {
			method: 'POST',
			headers: {
				'Content-Type': 'application/json',
				'Authorization': `Bearer ${endpointAPIKey}`,
				...(proxyEndpoint ? { 'X-Real-URL': endpoint } : {})
			},
			body: JSON.stringify({
				prompt: options.content
			}),
			signal,
		});
		if (!res.ok)
			throw new Error(`HTTP ${res.status}`);
		const tokens = await res.json();
		return tokens.length;
	} catch (e) {
		return -1;
	}
}

async function openaiOobaTokenCount({ endpoint, proxyEndpoint, signal, ...options }) {
	try {
		const res = await fetch(`${proxyEndpoint ?? endpoint}/v1/internal/token-count`, {
			method: 'POST',
			headers: {
				'Content-Type': 'application/json',
				...(proxyEndpoint ? { 'X-Real-URL': endpoint } : {})
			},
			body: JSON.stringify({
				text: options.content
			}),
			signal,
		});
		if (!res.ok)
			throw new Error(`HTTP ${res.status}`);
		const { length } = await res.json();
		return length;
	} catch (e) {
		return -1;
	}
}

async function openaiTabbyTokenCount({ endpoint, endpointAPIKey, proxyEndpoint, signal, ...options }) {
	try {
		const res = await fetch(`${proxyEndpoint ?? endpoint}/v1/token/encode`, {
			method: 'POST',
			headers: {
				'Content-Type': 'application/json',
				'Authorization': `Bearer ${endpointAPIKey}`,
				...(proxyEndpoint ? { 'X-Real-URL': endpoint } : {})
			},
			body: JSON.stringify({
				text: options.content
			}),
			signal,
		});
		if (!res.ok)
			throw new Error(`HTTP ${res.status}`);
		const tokens = await res.json();
		return tokens.length;
	} catch (e) {
		return -1;
	}
}

async function openaiTokenize({ endpoint, endpointAPIKey, proxyEndpoint, signal, ...options }) {
	try {
		const res = await fetch(`${proxyEndpoint ?? endpoint}/v1/internal/encode`, {
			method: 'POST',
			headers: {
				'Content-Type': 'application/json',
				...(proxyEndpoint ? { 'X-Real-URL': endpoint } : {})
			},
			body: JSON.stringify({
				text: options.content
			}),
			signal,
		});
		if (!res.ok)
			throw new Error(`HTTP ${res.status}`);
		const { tokens } = await res.json();

		const strings = [];
		for (let i=0; i<tokens.length; i++) {
			const string = await openaiDetokenize({
					endpoint,
					...(endpointAPIKey ? {
						endpointAPIKey,
					} : {}),
					tokens: [ tokens[i] ],
					signal: signal,
			});
			strings.push(string);
		};
		return {ids:tokens,str:strings};

	} catch (e) {
		reportError(e);
		return -1;
	}
}
async function openaiDetokenize({ endpoint, endpointAPIKey, proxyEndpoint, signal, ...options }) {

	const res = await fetch(`${proxyEndpoint ?? endpoint}/v1/internal/decode`, {
		method: 'POST',
		headers: {
			'Content-Type': 'application/json',
			...(proxyEndpoint ? { 'X-Real-URL': endpoint } : {})
		},
		body: JSON.stringify(options),
		signal,
	});
	if (!res.ok)
		throw new Error(`HTTP ${res.status}`);
	const { text } = await res.json();
	return text
}

async function openaiModels({ endpoint, endpointAPIKey, proxyEndpoint, signal, ...options }) {
	const isTogetherAI = endpoint.toLowerCase().includes("together.xyz");

	const res = await fetch(`${proxyEndpoint ?? endpoint}/v1/models`, {
		method: 'GET',
		headers: {
			'Content-Type': 'application/json',
			'Authorization': `Bearer ${endpointAPIKey}`,
			...(proxyEndpoint ? { 'X-Real-URL': endpoint } : {})
		},
		signal,
	});
	if (!res.ok)
		throw new Error(`HTTP ${res.status}`);

	const response = await res.json();
	let data;

	if (isTogetherAI) {
		// TogetherAI returns an array.
		data = response;
	} else {
		data = response.data;
	}
	return data.map(item => item.id);
}

function openaiConvertOptions(options, endpoint){
	const isOpenAI = endpoint.toLowerCase().includes("openai.com");
	const isTogetherAI = endpoint.toLowerCase().includes("together.xyz");
	const swapOption = (lhs, rhs) => {
		if (lhs in options) {
			options[rhs] = options[lhs];
			delete options[lhs];
		}
	};
	if (options.n_predict === -1) {
		options.n_predict = 1024;
	}
	if (isOpenAI && options.n_probs > 5) {
		options.n_probs = 5;
	}
	if (isTogetherAI && options.n_probs > 1) {
		options.n_probs = 1;
	}
	if ("dynatemp_range" in options && options.dynatemp_range !== 0) {
		// oobabooga specific.
		options.dynamic_temperature = true;
		options.dynatemp_low = Math.max(0, options.temperature - options.dynatemp_range);
		options.dynatemp_high = Math.max(0, options.temperature + options.dynatemp_range);
	}
	if (!isOpenAI && options.temperature === 0) {
		// oobabooga specific.
		options.do_sample = false;
	}
	swapOption("n_ctx", "max_context_length");
	swapOption("n_predict", "max_tokens");
	swapOption("n_probs", "logprobs");
	swapOption("repeat_penalty", "repetition_penalty");
	swapOption("repeat_last_n", "repetition_penalty_range");
	swapOption("tfs_z", "tfs");
	swapOption("mirostat", "mirostat_mode");
	swapOption("ignore_eos", "ban_eos_token")
	return options;
}

async function* openaiCompletion({ endpoint, endpointAPIKey, proxyEndpoint, signal, ...options }) {
	const res = await fetch(`${proxyEndpoint ?? endpoint}/v1/completions`, {
		method: 'POST',
		headers: {
			'Content-Type': 'application/json',
			'Authorization': `Bearer ${endpointAPIKey}`,
			...(proxyEndpoint ? { 'X-Real-URL': endpoint } : {})
		},
		body: JSON.stringify({
			...openaiConvertOptions(options, endpoint),
			stream: true,
		}),
		signal,
	});
	if (!res.ok)
		throw new Error(`HTTP ${res.status}`);
	for await (const chunk of parseEventStream(res.body)) {
		const logprobs = Object.entries(chunk.choices[0].logprobs?.top_logprobs?.[0] ?? {});
		const probs = logprobs.map(([tok, logprob]) => ({ tok_str: tok, prob: Math.exp(logprob) }));
		yield {
			content: chunk.choices[0].text,
			completion_probabilities: [{
				content: chunk.choices[0].text,
				probs
			}]
		};
	}
}

async function openaiOobaAbortCompletion({ endpoint, proxyEndpoint, ...options }) {
	try {
		await fetch(`${proxyEndpoint ?? endpoint}/v1/internal/stop-generation`, {
			method: 'POST',
			headers: {
				...(proxyEndpoint ? { 'X-Real-URL': endpoint } : {})
			},
		});
	} catch (e) {
		// do nothing
	}
}

function InputBox({ label, className, tooltip, tooltipSize, value, type, datalist, onValueChange, children, ...props }) {
	return html`
		<label className="InputBox ${tooltip ? 'tooltip' : ''}">
			${label}
			<div className="${children ? 'hbox-flex' : ''}">
				<input
					className="flex1 ${className}"
					type=${type || 'text'}
					list="${datalist ? label : ''}"
					value=${value}
					size="1"
					onChange=${({ target }) => {
						let value = type === 'number' ? target.valueAsNumber : target.value;
						if (props.inputmode === 'numeric') {
							props.pattern = '^-?[0-9]*$';
							if (value && !isNaN(+value))
								value = +target.value;
						}
						if (props.pattern && !new RegExp(props.pattern).test(value))
							return;
						onValueChange(value);
					}}
					...${props}/>
				${children}
			</div>
			${datalist && html`
				<datalist id="${label}">
					${datalist.map(opt => html`
						<option key="${opt}">
							${opt}
						</option>`)}
				</datalist>`}
			${tooltip && html`
				<span class="tooltiptext ${tooltipSize || ''}">
					${tooltip}
				</span>`}
		</label>`;
}

function SelectBox({ label, value, onValueChange, options, ...props }) {
	return html`
		<label className="SelectBox">
			${label}
			<select
				value=${value}
				onChange=${({ target }) => onValueChange(JSON.parse(target.value))}
				...${props}>
				${(options = typeof options === 'function' ? options() : options).map(o => html`<option
					key=${JSON.stringify(o.value)}
					value=${JSON.stringify(o.value)}>${o.name}</option>`)}
			</select>
		</label>`;
}
function SelectBoxTemplate({ label, value, onValueChange, options, ...props }) {
	return html`
		<label className="SelectBox">
			${label}
			<select
				value=${value}
				onChange=${({ target }) => onValueChange(JSON.parse(JSON.stringify(target.value)))}
				...${props}>
				${(options = typeof options === 'function' ? options() : options).map(o => html`<option
					key=${JSON.stringify(o.value)}
					value=${o.nameNew}>${o.nameNew}</option>`)}
			</select>
		</label>`;
}

function Checkbox({ label, value, onValueChange, ...props }) {
	return html`
		<label className="Checkbox">
			<input
				type="checkbox"
				checked=${value}
				onChange=${({ target }) => onValueChange(target.checked)}
				...${props}/>
			${label}
		</label>`;
}

function CollapsibleGroup({ label, expanded, children }) {
	const contentArea = useRef(null);
	const [contentHeight, setContentHeight] = useState(!expanded ? 0 : '');
	const [isCollapsed, setIsCollapsed] = useState(!expanded);

	useEffect(() => {
		setContentHeight(contentArea.current.scrollHeight);
		const observer = new SVResizeObserver(() => {
			setContentHeight(contentArea.current.scrollHeight);
		});
		observer.observe(contentArea.current);
		return () => observer.disconnect();
	}, []);

	useEffect(() => {
		setContentHeight(contentArea.current.scrollHeight);
	}, [isCollapsed]);

	const expandSvg = html`<svg fill="var(--color-light)" height="12" width="12" viewBox="0 0 330 330"><path d="M325.607,79.393c-5.857-5.857-15.355-5.858-21.213,0.001l-139.39,139.393L25.607,79.393 c-5.857-5.857-15.355-5.858-21.213,0.001c-5.858,5.858-5.858,15.355,0,21.213l150.004,150c2.813,2.813,6.628,4.393,10.606,4.393 s7.794-1.581,10.606-4.394l149.996-150C331.465,94.749,331.465,85.251,325.607,79.393z"/></svg>`;
	const collapseSvg = html`<svg fill="var(--color-light)" height="12" width="12" viewBox="0 0 330 330"><path d="M325.606,229.393l-150.004-150C172.79,76.58,168.974,75,164.996,75c-3.979,0-7.794,1.581-10.607,4.394 l-149.996,150c-5.858,5.858-5.858,15.355,0,21.213c5.857,5.857,15.355,5.858,21.213,0l139.39-139.393l139.397,139.393 C307.322,253.536,311.161,255,315,255c3.839,0,7.678-1.464,10.607-4.394C331.464,244.748,331.464,235.251,325.606,229.393z"/></svg>`;

	return html`
		<div className="collapsible-group">
			<div className="collapsible-header" onClick=${() => setIsCollapsed(!isCollapsed)}>
				${isCollapsed ? expandSvg : collapseSvg}
				${label}
			</div>
			<div
				ref=${contentArea}
				className="collapsible-content ${isCollapsed ? 'collapsed' : 'expanded'}"
				style=${{ 'max-height': isCollapsed ? 0 : contentHeight }}>
				${children}
			</div>
		</div>`;
}

function Sessions({ sessionStorage, disabled }) {
	const [version, setVersion] = useState(0);
	const [newSessionName, setNewSessionName] = useState('');
	const [renameSessionName, setRenameSessionName] = useState('');
	const [renamingId, setRenamingId] = useState(undefined);
	const [isCreating, setIsCreating] = useState(false);

	useEffect(() => {
		const incrementVersion = () => setVersion(v => v + 1);
		sessionStorage.addEventListener('change', incrementVersion);
		return () => sessionStorage.removeEventListener('change', incrementVersion);
	}, []);

	const switchSession = async (sessionId) => {
		if (sessionStorage.selectedSession != sessionId) {
			await sessionStorage.switchSession(sessionId);
		}
	};

	const startRenameSession = (sessionId, name) => {
		setRenameSessionName(name);
		setRenamingId(sessionId);
	};

	const renameSession = async (sessionId) => {
		if (renameSessionName) {
			await sessionStorage.renameSession(sessionId, renameSessionName);
			setRenamingId(undefined);
		}
	};

	const deleteSession = async (sessionId) => {
		await sessionStorage.deleteSession(sessionId);
	};

	const startCreateSession = () => {
		setNewSessionName(`MikuPad #${sessionStorage.nextId + 1}`);
		setIsCreating(true);
	};

	const createSession = async () => {
		if (newSessionName) {
			const newId = await sessionStorage.createSession(newSessionName);
			await sessionStorage.switchSession(newId);
			setIsCreating(false);
		}
	};

	const importSession = () => {
		const fileInput = document.createElement("input");
		fileInput.type = 'file';
		fileInput.style.display = 'none';
		fileInput.onchange = (e) => {
			const file = e.target.files[0];
			if (!file)
				return;
			const reader = new FileReader();
			reader.onload = (e) => {
				const contents = e.target.result;
				fileInput.func(contents);
			}
			reader.readAsText(file);
		};
		fileInput.func = async (text) => {
			const newId = await sessionStorage.createSessionFromObject(JSON.parse(text), false);
			await sessionStorage.switchSession(newId);
		};
		document.body.appendChild(fileInput);
		fileInput.click();
		document.body.removeChild(fileInput);
	};

	const exportSession = () => {
		const sessionObj = { ...sessionStorage.sessions[sessionStorage.selectedSession] };
		for (const [key, value] of Object.entries(sessionObj)) {
			// This is done for compatibility with localStorage export files.
			sessionObj[key] = JSON.stringify(value);
		}
		exportText(`${sessionStorage.getProperty('name')}.json`, JSON.stringify(sessionObj));
	};

	const cloneSession = async () => {
		const sessionObj = { ...sessionStorage.sessions[sessionStorage.selectedSession] };
		for (const [key, value] of Object.entries(sessionObj)) {
			// This is done for compatibility with localStorage export files.
			sessionObj[key] = JSON.stringify(value);
		}
		const newId = await sessionStorage.createSessionFromObject(sessionObj, true);
		await sessionStorage.switchSession(newId);
	};

	function handleKeyDown(sessionId, key) {
		if (event.key === 'Enter') {
			if (isCreating)
				createSession();
			else if (renamingId !== undefined)
				renameSession(sessionId);
		} else if (event.key === 'Escape') {
			if (isCreating)
				setIsCreating(false);
			else if (renamingId !== undefined)
				setRenamingId(undefined);
		}
	}

	const trashSvg = html`<svg fill="var(--color-light)" width="16" height="16" viewBox="0 0 490.646 490.646"><path d="m399.179 67.285-74.794.033L324.356 0 166.214.066l.029 67.318-74.802.033.025 62.914h307.739l-.026-63.046zM198.28 32.11l94.03-.041.017 35.262-94.03.041-.017-35.262zM91.465 490.646h307.739V146.359H91.465v344.287zm225.996-297.274h16.028v250.259h-16.028V193.372zm-80.14 0h16.028v250.259h-16.028V193.372zm-80.141 0h16.028v250.259H157.18V193.372z"/></svg>`;
	const renameSvg = html`<svg fill="var(--color-light)" width="16" height="16" viewBox="0 0 512 448"><path style=${{ fillOpacity: 1, stroke: 'none', strokeWidth: 30, strokeLinecap: 'round', strokeMiterlimit: 4, strokeDasharray: 'none', strokeOpacity: 1 }} d="M0 96v256h320v-32H32V128h288V96H0zM416 96v32h64v192h-64v32h96V96h-96z" /><path style=${{ fillOpacity: 1, stroke: 'none', strokeWidth: 30, strokeLinecap: 'round', strokeMiterlimit: 4, strokeDasharray: 'none', strokeOpacity: 1 }} d="M352 636.362h32v384h-32z" transform="matrix(1, 0, 0, 1, 0, -604.3619995117188)" /><path style=${{ fillOpacity: 1, stroke: 'none', strokeWidth: 30, strokeLinecap: 'round', strokeMiterlimit: 4, strokeDasharray: 'none', strokeOpacity: 1 }} transform="matrix(0, 1, -1, 0, 0, -604.3619995117188)" d="M1020.362-448h32v64h-32zM1020.362-352h32v64h-32zM604.362-448h32v64h-32zM604.362-352h32v64h-32zM764.362-288h128v224h-128z" /></svg>`;

	const confirmSvg = html`<svg width="16" height="16" viewBox="0 0 128 128"><circle cx="64" cy="64" r="64" fill="var(--color-dark)"/><path d="M54.3 97.2 24.8 67.7c-.4-.4-.4-1 0-1.4l8.5-8.5c.4-.4 1-.4 1.4 0L55 78.1l38.2-38.2c.4-.4 1-.4 1.4 0l8.5 8.5c.4.4.4 1 0 1.4L55.7 97.2c-.4.4-1 .4-1.4 0z" fill="var(--color-light)"/></svg>`;
	const cancelSvg = html`<svg width="16" height="16" viewBox="0 0 128 128"><circle cx="64" cy="64" r="64" fill="var(--color-dark)"/><path d="M100.3 90.4 73.9 64l26.3-26.4c.4-.4.4-1 0-1.4l-8.5-8.5c-.4-.4-1-.4-1.4 0L64 54.1 37.7 27.8c-.4-.4-1-.4-1.4 0l-8.5 8.5c-.4.4-.4 1 0 1.4L54 64 27.7 90.3c-.4.4-.4 1 0 1.4l8.5 8.5c.4.4 1.1.4 1.4 0L64 73.9l26.3 26.3c.4.4 1.1.4 1.5.1l8.5-8.5c.4-.4.4-1 0-1.4z" fill="var(--color-light)"/></svg>`;

	return html`
		<div className="Sessions ${disabled ? 'disabled' : ''}">
			<ul>
				${isCreating && html`
					<li key=-1>
						<a className="Session">
							<input
								type="text"
								value=${newSessionName}
								onChange=${(e) => setNewSessionName(e.target.value)}
								onKeyDown=${(e) => handleKeyDown(undefined, e.key)}
								onClick=${(e) => e.stopPropagation()}
								autoFocus
							/>
							<div className="flex-separator"></div>
							<button onClick=${(e) => (createSession(), e.stopImmediatePropagation?.())}>${confirmSvg}</button>
							<button onClick=${(e) => (setIsCreating(false), e.stopImmediatePropagation?.())}>${cancelSvg}</button>
						</a>
					</li>
				`}
				${Object.entries(sessionStorage.sessions).reverse().map(([sessionId, session]) => html`
					<li key=${sessionId}>
						<a className="Session ${sessionStorage.selectedSession == sessionId ? 'selected' : ''}"
							onClick=${() => switchSession(+sessionId)}>
							${renamingId == sessionId ? html`
								<input
									type="text"
									value=${renameSessionName}
									onChange=${(e) => setRenameSessionName(e.target.value)}
									onKeyDown=${(e) => handleKeyDown(+sessionId, e.key)}
									onClick=${(e) => e.stopPropagation()}
									autoFocus
								/>
								<div className="flex-separator"></div>
								<button onClick=${(e) => (renameSession(+sessionId), e.stopImmediatePropagation())}>${confirmSvg}</button>
								<button onClick=${(e) => (setRenamingId(undefined), e.stopImmediatePropagation())}>${cancelSvg}</button>
							` : html`
								${session.name}
								<div className="flex-separator"></div>
								<button
									onClick=${(e) => (startRenameSession(+sessionId, session.name), e.stopPropagation())}>
									${renameSvg}
								</button>
								<button
									onClick=${(e) => (deleteSession(+sessionId), e.stopPropagation())}>
									${trashSvg}
								</button>
							`}
						</a>
					</li>
				`)}
			</ul>
			<div className="vbox">
				<button disabled=${disabled} onClick=${startCreateSession}>Create</button>
				<button disabled=${disabled} onClick=${importSession}>Import</button>
				<button disabled=${disabled} onClick=${exportSession}>Export</button>
				<button disabled=${disabled} onClick=${cloneSession}>Clone</button>
			</div>
		</div>`;
}



function Modal({ isOpen, onClose, title, description, children, ...props }) {
	if (!isOpen) {
		return null;
	}

	useEffect(() => {
		const onKeyDown = (event) => {
			if (event.key === 'Escape') {
				onClose();
			}
		};
		document.addEventListener('keydown', onKeyDown);
		return () => {
			document.removeEventListener('keydown', onKeyDown);
		};
	}, []);

	return html`
		<div className="modal-overlay" onClick=${onClose}>
			<div className="modal-container">
				<div className="modal" onClick=${(e) => e.stopPropagation()} ...${props}>
					<div class="modal-title">${title}</div>
					${ description=="" ? false : html`<div style=${{ whiteSpace: 'pre-line' }} class='modal-desc'>${description}</div>` }
					<hr/>
					<div className="modal-content">
						${children}
					</div>
					<button
					class="button-modal-top"
					onClick=${onClose}>
						<svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="-1 -1 10 10" xmlns="http://www.w3.org/2000/svg"><path d="M 0 1 L 3 4 L 0 7 L 1 8 L 4 5 L 7 8 L 8 7 L 5 4 L 8 1 L 7 0 L 4 3 L 1 0 L 1 0 Z"></path></svg>
					</button>
				</div>
			</div>
		</div>`;
}

function EditorPreferencesModal({ isOpen, closeModal, children }) {
	return html`
		<${Modal} isOpen=${isOpen} onClose=${closeModal}
			title="Editor Preferences"
			description=""
			style=${{ 'max-width': '20em' }}>
				<div className="vbox">
					${children}
				</div>
			</${Modal}>`;
}

function MemoryModal({ isOpen, closeModal, memoryTokens, handleMemoryTokensChange, cancel }) {
	return html`
		<${Modal} isOpen=${isOpen} onClose=${closeModal}
			title="Memory"
			description="This text will be added at the very top of your context.
			Prefix and suffix will be attached at the beginning or end of your memory respectively. \\n for newlines in pre/suffix.">
				<div className="hbox">
					<${InputBox} label="Prefix" type="text" placeholder="[INST]"
						readOnly=${!!cancel} value=${memoryTokens.prefix} onValueChange=${(value) => handleMemoryTokensChange("prefix", value)}/>
					<${InputBox} label="Suffix" type="text" placeholder="[/INST]"
						readOnly=${!!cancel} value=${memoryTokens.suffix} onValueChange=${(value) => handleMemoryTokensChange("suffix", value)}/>
				</div>
				<div class="relative">
					<textarea
						readOnly=${!!cancel}
						placeholder="Anything written here will be injected at the head of the prompt. Tokens here DO count towards the Context Limit."
						defaultValue=${memoryTokens.text}
						value=${memoryTokens.text}
						onInput=${(e) => handleMemoryTokensChange("text", e.target.value) }
						class="expanded-text-area-settings"
						id="memory-area-settings"/>
					<div class="token-counter">
						${memoryTokens.tokens}
					</div>
				</div>
			</${Modal}>`;
}

function AuthorNoteModal({ isOpen, closeModal, authorNoteTokens, handleauthorNoteTokensChange, authorNoteDepth, setAuthorNoteDepth, cancel }) {
	const handleAuthorNoteDepthChange = (value) => {
		setAuthorNoteDepth(!isNaN(+value) && value >= 0 ? value : 0);
	};

	return html`
		<${Modal} isOpen=${isOpen} onClose=${closeModal}
			title="Author's Note"
			description="This text will be injected N newlines from the bottom of your prompt.
			Prefix and suffix will be attached at the beginning or end of your author's note respectively. \\n for newlines in pre/suffix.">
				<div className="hbox">
					<${InputBox} label="Prefix" type="text" placeholder="[INST]"
						readOnly=${!!cancel} value=${authorNoteTokens.prefix} onValueChange=${(value) => handleauthorNoteTokensChange("prefix", value)}/>
					<${InputBox} label="Suffix" type="text" placeholder="[/INST]"
						readOnly=${!!cancel} value=${authorNoteTokens.suffix} onValueChange=${(value) => handleauthorNoteTokensChange("suffix", value)}/>
					<${InputBox} label="AN Injection Depth (0-N)" type="number" step="1"
						readOnly=${!!cancel} value=${authorNoteDepth} onValueChange=${handleAuthorNoteDepthChange}/>
				</div>
				<div class="relative">
					<textarea
						readOnly=${!!cancel}
						placeholder="Anything written here will be injected ${authorNoteDepth} newlines from bottom into context."
						defaultValue=${authorNoteTokens.text}
						value=${authorNoteTokens.text}
						onInput=${(e) => handleauthorNoteTokensChange("text", e.target.value) }
						class="expanded-text-area-settings"
						id="expanded-an-settings"/>
					<div class="token-counter">
						${authorNoteTokens.tokens}
					</div>
				</div>
			</${Modal}>`;
}

function ContextModal({ isOpen, closeModal, tokens, memoryTokens, authorNoteTokens, handleMemoryTokensChange, modifiedPrompt, defaultPresets, cancel }) {
	return html`
		<${Modal} isOpen=${isOpen} onClose=${closeModal}
			title="Context"
			description="This is the prompt being sent to your large language model.">
			<div id="advancedContextPlaceholders">
			<table id="contextTokensTable" border="1" frame="void" rules="all">
				<thead>
					<tr>
						<th></th>
						<th>Memory</th>
						<th>World Info</th>
						<th>Author's Note</th>
						<th>Prompt</th>
						<th></th>
						<th>Total</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<th>Tokens</th>
						<td>${memoryTokens.tokens}</td>
						<td>${memoryTokens.tokensWI}</td>
						<td>${authorNoteTokens.tokens}</td>
						<td>${tokens - authorNoteTokens.tokens - memoryTokens.tokensWI - memoryTokens.tokens}</td>
						<td></td>
						<td>${tokens}</td>
					</tr>
				</tbody>
			</table>
			</div>
			<${CollapsibleGroup} label="Advanced Context Ordering">
				<div id="context-order-desc">
					You can use the following placeholders to order the context according to your needs:<br />
					<div id="advancedContextPlaceholders">
						<table border="1" frame="void" rules="all">
							<thead>
							<tr>
								<th></th>
								<th>Prefix</th>
								<th>Text</th>
								<th>Suffix</th>
							</tr>
							</thead>
							<tbody>
							<tr>
								<th>Memory</th>
								<td>{memPrefix}</td>
								<td>{memText}</td>
								<td>{memSuffix}</td>
							</tr>
							<tr>
								<th>World Info</th>
								<td>{wiPrefix}</td>
								<td>{wiText}</td>
								<td>{wiSuffix}</td>
							</tr>
							<tr>
								<th>Prompt</th>
								<td></td>
								<td>{prompt}</td>
								<td></td>
							</tr>
							</tbody>
						</table>
					</div>
					Any text that is not a placeholder will be added into the context as is.
				</div>
				<textarea
					readOnly=${!!cancel}
					placeholder=${defaultPresets.memoryTokens.contextOrder}
					defaultValue=${memoryTokens.contextOrder}
					value=${memoryTokens.contextOrder}
					onInput=${(e) => handleMemoryTokensChange("contextOrder", e.target.value)}
					class="expanded-text-area-settings"
					id="advanced-context-order-settings"/>
			</${CollapsibleGroup}>
			<textarea
				readOnly=${!!cancel}
				value=${modifiedPrompt}
				class="expanded-text-area-settings"
				id="context-area-settings" readOnly/>
		</${Modal}>`;
}

function WorldInfoModal({ isOpen, closeModal, worldInfo, setWorldInfo, cancel }) {
	const handleWorldInfoNew = () => {
		setWorldInfo((prevWorldInfo) => {
			return {
				...prevWorldInfo,
				entries: [ { "displayName":"New Entry","text":"","keys":[], "search":"" },...prevWorldInfo.entries ],
			};
		});
	};
	const handleWorldInfoMove = (index,move) => {
		const modEntries = worldInfo.entries;
		if (index+move < 0 || index+move > modEntries.length-1 ) {
			return;
		}
		modEntries.splice(index+move, 0, modEntries.splice(index, 1)[0]);
		setWorldInfo((prevWorldInfo) => {
			return {
				...prevWorldInfo,
				entries: [ ...modEntries ],
			};
		});
	};
	const handleWorldInfoDel = (index) => {
		if (!window.confirm("Are you sure you want to delete the world info entry #" + (index + 1) + ": "+ worldInfo.entries[index].displayName + "?\nThis action cannot be undone."))
			return;
		if (index > -1 && index < worldInfo.entries.length) {
			setWorldInfo((prevWorldInfo) => {
				console.warn(`Deleting world info entry #${(index + 1)}:`,prevWorldInfo.entries[index])
				return {
					...prevWorldInfo,
					entries: prevWorldInfo.entries.filter((_, i) => i !== index),
				};
			});
		}
		else {
			alert("Index " + index + " out of range!");
		}
	};
	const handleWorldInfoChange = (key,index,value) => {
		setWorldInfo((prevWorldInfo) => {
			const updatedEntries = [...prevWorldInfo.entries];
			const updatedEntry = key == "keys"
				? { ...updatedEntries[index], [key]: value.split(/(?<!\\), ?/) } //.map(item => item.trim())
				: { ...updatedEntries[index], [key]: value };
			updatedEntries[index] = updatedEntry;

			return {
				...prevWorldInfo,
				entries: updatedEntries,
			};
		});
	};
	const handleWorldInfoAffixChange = (key, value) => {
		setWorldInfo((prevWorldInfo) => ({
			...prevWorldInfo,
			[key]: value,
		}));
	};

	return html`
		<${Modal} isOpen=${isOpen} onClose=${closeModal}
			title="World Info"
			description="Additional information that is added when specific keywords are found in context.
			World info will be added at the top of your memory, in the order specified here.

			Each entry will begin on a newline. Keys will be interpreted as case-insensitive regular expressions. Search Range specifies how many tokens back into the context will be searched for activation keys. Search range 0 to disable an entry.">
			<div id="modal-wi-global">
				<${CollapsibleGroup} label="Prefix/Suffix">
					The prefix and suffix will be added at the beginning or end of all your active World Info entries respectively.
					<br />
					<div className="hbox">
						<${InputBox} label="Prefix" type="text" placeholder="\\n"
							readOnly=${!!cancel} value=${worldInfo.prefix} onValueChange=${(value) => handleWorldInfoAffixChange("prefix", value)}/>
						<${InputBox} label="Suffix" type="text" placeholder="\\n"
							readOnly=${!!cancel} value=${worldInfo.suffix} onValueChange=${(value) => handleWorldInfoAffixChange("suffix", value)}/>
					</div>
				</${CollapsibleGroup}>
				<button id="button-wi-new" disabled=${!!cancel} onClick=${handleWorldInfoNew}>New Entry</button>
			</div>
			<div className="modal-wi-content overflow-container">
				${!Array.isArray(worldInfo.entries) ? null : worldInfo.entries.map((entry, index) => html`
					<div class="wi-entry" key=${index}>
						<div class="wi-entry-controls">
							<div class="wi-entry-filler" />
							<div class="wi-entry-name">
								<${InputBox}
								label="Entry #${index+1}"
								type="text"
								readOnly=${!!cancel}
								placeholder="Name of this entry"
								value=${entry.displayName}
								onValueChange=${(value) => handleWorldInfoChange("displayName",index,value)}
								/>
							</div>
							<div class="wi-entry-buttons">
								<div class="wi-entry-buttons-container">
									<button disabled=${!!cancel} onClick=${() => handleWorldInfoMove(index,-1)}>
										<svg fill="var(--color-light)" height="12" width="12" viewBox="0 0 330 330"><path d="M325.606,229.393l-150.004-150C172.79,76.58,168.974,75,164.996,75c-3.979,0-7.794,1.581-10.607,4.394 l-149.996,150c-5.858,5.858-5.858,15.355,0,21.213c5.857,5.857,15.355,5.858,21.213,0l139.39-139.393l139.397,139.393 C307.322,253.536,311.161,255,315,255c3.839,0,7.678-1.464,10.607-4.394C331.464,244.748,331.464,235.251,325.606,229.393z"/></svg>
									</button>
									<button disabled=${!!cancel} onClick=${() => handleWorldInfoDel(index)}>
										✕
									</button>
									<button disabled=${!!cancel} onClick=${() => handleWorldInfoMove(index,1)}>
										<svg fill="var(--color-light)" height="12" width="12" viewBox="0 0 330 330"><path d="M325.607,79.393c-5.857-5.857-15.355-5.858-21.213,0.001l-139.39,139.393L25.607,79.393 c-5.857-5.857-15.355-5.858-21.213,0.001c-5.858,5.858-5.858,15.355,0,21.213l150.004,150c2.813,2.813,6.628,4.393,10.606,4.393 s7.794-1.581,10.606-4.394l149.996-150C331.465,94.749,331.465,85.251,325.607,79.393z"/></svg>
									</button>
								</div>
							</div>
							<div class="wi-entry-text">
								<div class="hbox">
									<${InputBox}
										label="Comma Separated RegEx Keys"
										type="text"
										readOnly=${!!cancel}
										value=${entry.keys.join(',')}
										placeholder="Required to activate entry"
										onValueChange=${(value) => handleWorldInfoChange("keys",index,value)}
										/>
									<${InputBox}
										label="Search Range (0 = disabled)"
										tooltip="Currently not accurate to the token count, it will be used as an estimate."

										type="text"
										readOnly=${!!cancel}
										inputmode="numeric"
										value=${entry.search}
										placeholder="2048"
										onValueChange=${(value) => handleWorldInfoChange("search",index,value)}
										/>
								</div>
								<label class="TextArea">
									Text
									<textarea
										readOnly=${!!cancel}
										placeholder="Information to be inserted into context when key is found"
										value=${entry.text ? entry.text : ""}
										defaultValue=${entry.text ? entry.text : ""}
										onInput=${(e) => handleWorldInfoChange("text",index, e.target.value)}
										class="wi-textarea" />
								</label>
							</div>
						</div>
					</div>`)}
			</div>
		</${Modal}>`;
}

function LogitBiasModal({ isOpen, closeModal, logitBias, setLogitBias, logitBiasParam, setLogitBiasParam, sessionStorage, endpoint, endpointAPI, endpointAPIKey, isMikupadEndpoint, cancel }) {
	const [lastBiasError, setLastBiasError] = useState(undefined);
	const [logitBiasTemp, setLogitBiasTemp] = useState([]);
	const [logitBiasSorted, setLogitBiasSorted] = useState([]);
	const [logitBiasInput, setLogitBiasInput] = useState({power:"0",string:""});

	const handleLogitBiasInput = (key,value) => {
		setLogitBiasInput((prevLogitBiasInput) => {
			return {
				...prevLogitBiasInput,
				[key]: value
			}
		});
	};

	const logitBiasAdd = async (biasPower="",biasString="",origValue="") => {
		setLastBiasError(undefined);
		// abort if no input or power is NaN
		if(!biasString) {
			return;
		}
		if (isNaN(+biasPower) || biasPower == "") { 
			setLastBiasError("Error: Bias must be a number");
			return;
		}
		biasPower = Number(biasPower);

		const modBias = logitBias.bias;

		// delete entry if power 0 or empty
		if (biasPower == 0) {	
			if (!logitBias.bias[biasString]) {
				setLastBiasError("Error: Bias 0 = no Bias");
				return;
			}
			console.log("delete",biasString);
			setLogitBias((prevLogitBias) => {
				delete modBias[biasString];
				return { 
					...prevLogitBias,
					bias: {
						...modBias
					}
				};
			})
			return;
		}
		// if overwriting the string value of an entry, delete the original one
		if (origValue && origValue != biasString) {
			delete modBias[origValue];
		}

		const ac = new AbortController();
		try {
			// if the string is a comma separated list of numbers wrapped in /
			var tokens
			const isTokenIds = biasString.match(/^(?<!\\)\/(\s*\d+\s*,?\s*)+(?<!\\)\/$/g);
			if ( isTokenIds != null ) {
				// split by "," and use it as token ids directly
				tokens = {
					ids: isTokenIds[0].replaceAll("/","").split(",").map( item => Number(item.trim()) ),
					str: ""
				};
			}
			// else process like normal
			else {
				// KNOWN ISSUE: some models automatically prepend a space to any tokenization 
				// input. to work around this, I'm prepending the input with a "!==", then 
				// slicing the output array by the number of tokens of "!==".
				// This could cause issues when trying to bias a token starting with ? where
				// ? is any character that forms a single token together with " !==", like 
				// this: " !==?" I've chosen "!==" because it seems to be a very conserved
				// token between models.
				//
				// Now granted, I have not found any strings where this is actually an issue in 
				// the tokenizers of the models I use, but this is still a huge hackjob of a 
				// workaround. If anyone can think of a better solution, please let me know.
				tokens = await getTokens({
					endpoint,
					endpointAPI,
					...(endpointAPI == 3 || endpointAPI == 0 ? { endpointAPIKey } : {}),
					content: `!==${biasString}`.replace(/\\n/g,'\n'),
					signal: ac.signal,
					...(isMikupadEndpoint ? { proxyEndpoint: sessionStorage.proxyEndpoint } : {})
				});
				const logitBiasWorkaround = await getTokens({
					endpoint,
					endpointAPI,
					...(endpointAPI == 3 || endpointAPI == 0 ? { endpointAPIKey } : {}),
					content: `!==`,
					signal: ac.signal,
					...(isMikupadEndpoint ? { proxyEndpoint: sessionStorage.proxyEndpoint } : {})
				});
				// Remove however many tokens !== is tokenized as for the workaround
				tokens.ids = tokens.ids.slice(logitBiasWorkaround.ids.length);
				if ( Array.isArray(tokens.str) ) {
					tokens.str = tokens.str.slice(logitBiasWorkaround.ids.length);
				}
			}

			console.log("Biasing tokens [",tokens.ids.join(", "),"]",
				Array.isArray(tokens.str) ? "'"+tokens.str.join("|")+"'"
					: "'"+biasString+"'",
				"by power",biasPower)
			await setLogitBias((prevLogitBias) => ({
				...prevLogitBias,
				bias: {
					...modBias,
					[biasString]: { // removed Number() here
						ids: [ ...tokens.ids ],
						strings: [ ...tokens.str ],
						power: biasPower
					}
				}
			}));
		}
		catch(e) {
			if (e.name !== 'AbortError') {
				reportError(e);
				const errStr = e.toString();
				if ((endpointAPI == 3 || endpointAPI == 0) && errStr.includes("401")) {
					setLastBiasError("Error: Rejected API Key");
					setRejectedAPIKey(true);
				} else if (endpointAPI == 3 && errStr.includes("429")) {
					setLastBiasError("Error: Insufficient Quota");
				} else {
					setLastBiasError(errStr);
				}
			}
			return;
		}
	};

	const clamp = (num, min = -Infinity, max = Infinity) => {
		return Math.min(Math.max(num, min), max);
	};

	const llamaCppSetLogitBiasParams = () => {
		const param = [];
		// TODO grab multi-token strings here and put them in a separate state variable
		// for phrase bias
		Object.keys(logitBias.bias).forEach(entry => {
			// set banned tokens to false, else divide power by 10 to remain within
			// reasonable range
			const power = logitBias.bias[entry].power < -99 ? false : Number(logitBias.bias[entry].power) / 10;
			param.push( [ Number(logitBias.bias[entry].ids[0]), power ] );
		});
		setLogitBiasParam(param);
	};
	const koboldCppSetLogitBiasParams = () => {
		const param = {};
		Object.keys(logitBias.bias).forEach(entry => {
			// -100 to 100
			param[Number(logitBias.bias[entry].ids[0])] = clamp(Number(logitBias.bias[entry].power),-100,100)
		});
		setLogitBiasParam(param);
	};
	const openaiSetLogitBiasParams = () => {
		const param = {};
		Object.keys(logitBias.bias).forEach(entry => {
			// -100 to 100
			param[Number(logitBias.bias[entry].ids[0])] = clamp(Number(logitBias.bias[entry].power),-100,100).toFixed(1)
		});
		setLogitBiasParam(param);
	};

	useMemo(() => {
		// set the parameters sent to the model in the format expected by the endpoint
		switch (endpointAPI) {
			case 0:
				llamaCppSetLogitBiasParams();
				break;
			case 2:
				koboldCppSetLogitBiasParams();
				break;
			case 3:
				//openaiSetLogitBiasParams()
				// for some reason this causes an error
				break;
		}
	}, [logitBias, endpointAPI]);


	useEffect(() => {
		const tempArray = logitBiasSorted.map((string, index) =>  ({
			value: string,
			valueBack: string,
			strings: logitBias.bias[string].strings,
			tokens: logitBias.bias[string].ids,
			power: logitBias.bias[string].power
		}));
		setLogitBiasTemp({
			positive: tempArray.filter(item => item.power > 0),
			negative: tempArray.filter(item => item.power < 0)
		});
	},[logitBiasSorted,isOpen]);


	const handleBiasTempChange = (posneg, key, index, value) => {
		setLogitBiasTemp((prevLogitBiasTemp) => {
			const rest = { ...prevLogitBiasTemp };
			const updatedTemp = [ ...prevLogitBiasTemp[posneg] ];

			updatedTemp[index] = {
				...updatedTemp[index],
				[key]: value,
			};
			return {
				...rest,
				[posneg]: updatedTemp
			};
		});
	};

	useMemo(() => {
		const biasListToSort = Object.entries(logitBias.bias);
		const sortPowerString = (a, b) => {
			const powerDiff = parseInt(b[1].power) - parseInt(a[1].power);
			if (powerDiff !== 0) {
				// If powers are different, sort by power
				return powerDiff;
			} else {
				// If powers are the same, sort alphabetically by string value
				return a[0].localeCompare(b[0]);
			}
		};

		const biasListSorted = biasListToSort.sort(sortPowerString);
		const resultArray = biasListSorted.map(([key]) => key);

		setLogitBiasSorted(resultArray);
	}, [logitBias]);

	return html`
		<${Modal} isOpen=${isOpen} onClose=${closeModal}
			title="Logit Bias"
			description="Make certain tokens more or less likely to be generated. Recommended ranges are 100 to -100, with -100 being a total ban of the token.
			Currently only works on the first token of multi-token phrases/words.
			You can bias IDs directly in a comma separated list, wrapped in '/'. Example: /382,1449,1802/

			Different models might tokenize words differently. Always Re-Tokenize your biases when switching models by pressing the '+' button again for every entry.">
			${isOpen 
				&& html`
					<div className="hbox-flex logitBiasContainer">
						<div class="small-inputBox">
							<${InputBox} label="Bias" className="logitBiasPower-container"
								type="enumber"  max=100 min=-100 step=1
								readOnly=${!!cancel}
								onValueChange=${(value) => { handleLogitBiasInput("power",value)} }
								value=${logitBiasInput.power} 
								id="logitBiasPower"/>
						</div>
						<${InputBox} label="Token" type="text"
							tooltip="Currently, only the first token of multi-token strings will be biased."
							readOnly=${!!cancel}
							value=${logitBiasInput.string}
							placeholder="String or /ID,.../"
							onValueChange=${() => {} }
							onInput=${(e) => {handleLogitBiasInput("string",e.target.value)} }
							/>
						<button disabled=${!!cancel} class="hbox-button" onClick=${() => logitBiasAdd(logitBiasInput.power,logitBiasInput.string)}>
							+
						</button>
					</div>
					${!!lastBiasError && html`
						<div style=${{"margin":"8px auto"}} className="error-text">${lastBiasError}</div>`}
				<hr style=${{"width":"95%","margin":"8px auto"}} />
				<div class="lb-modal-biasList" >
					${Object.keys(logitBiasTemp).map((key) => {
						return html`
							<div class="overflow-container lb-modal-grid-column" id="lb-modal-${key}">
								${logitBiasTemp[key].map((bias, index) => {
									return html`
										<div class="lb-modal-entry lb-modal-grid-row" key=${index}>
											<${InputBox} label="Bias" class="lb-modal-power"
												type="enumber" max=100 min=-100 step=1
												id="lb-modal-power-${index}"
												readOnly=${!!cancel}
												onValueChange=${(value) => {handleBiasTempChange(key,"power", index, value)} }
												value=${bias.power}/>

											<${InputBox} label="Token" type="text"
												tooltip="Currently, only the first token of multi-token strings will be biased."
												readOnly=${!!cancel}
												value=${bias.value}
												placeholder="String or /ID,.../"
												onValueChange=${() => {} }
												onInput=${(e) => handleBiasTempChange(key,"value", index, e.target.value) }
												/>
											<div class="lb-modal-tokenized">
												${endpointAPI == 0 && bias.strings != ""
													? "["+bias.strings.join("|")+"] "
													: "["+bias.tokens+"]" } 

											</div>
											<button
												disabled=${!!cancel}
												class="hbox-button lb-modal-button lb-modal-button-add"
												onClick=${() => logitBiasAdd(bias.power, bias.value, bias.valueBack)}>
												+
											</button>
											<button
												disabled=${!!cancel}
												class="hbox-button lb-modal-button lb-modal-button-remove"
												onClick=${() => logitBiasAdd("0", bias.valueBack, bias.valueBack)}
												>
												-
											</button>
											<hr/>
										</div>`})}
							</div>`})}
				</div>`}
			</${Modal}>`;
}

function InstructModal({ isOpen, closeModal, templateStorage, selectedTemplate, setSelectedTemplate, templateList, setTemplateList, templates, templatesImport, setTemplates, cancel }) {
	const [addDeleteTemplate, setAddDeleteTemplate] = useState(false);
	const [newTemplateName, setNewTemplateName] = useState(undefined);

	function getArrObjByName(array,name,getIndex=false) {
		const index = array.findIndex(obj => obj.name === name)
		if (getIndex)
			return index
		return array[index == -1 ? 0 : index];
	}

	function handleInstructTemplateChange(templateName,key,value,back="") {
		const templateListMod = templateList
		const tempIndex = templateListMod.findIndex(obj => obj.name === templateName);
		const index = tempIndex < 0 ? 0 : tempIndex;

		if (key == "name") { 
			templateListMod[index].nameNew = value
			setNewTemplateName(value)
		} else {
			templateListMod[index].affixes[key] = value
		}
		setTemplateList((prevState) => ([
			...templateListMod
		]))
	}

	async function handleInstructTemplateAdd() {
		await updateTemplateDB()
		setTemplates((prevState) => {
			var newState = {
				...prevState
			}
			newState[""] = {
				"sysPre": "",
				"sysSuf": "",
				"instPre": "",
				"instSuf": "",
			}
			return { ...newState }
		})
		setAddDeleteTemplate(true)
	}

	async function handleInstructTemplateDelete(name) {
		if (Object.keys(templates).length < 2)
			return
		if (!window.confirm("Are you sure you want to delete this template? This action can't be undone."))
			return;

		console.warn("Deleting Template",name,":",templates[name])
		setTemplates((prevState) => {
			var newState = {
				...prevState
			}
			delete newState[name]
			return { ...newState }
		})
		setAddDeleteTemplate(true)
	}

	useEffect(() => {
		const index = templateList.findIndex(obj => obj.name === selectedTemplate)
		const reselectTemplate = templateList[index == -1 ? 0 : index]?.nameNew
		const list = []
		let i = 0;
		for (const key in templates) {
			list.push({
				name: key,
				nameNew:key,
				value: key,
				nameBack: key,
				affixes: templates[key]
			})
		}
		list.sort((a, b) => {
			var nameA = a.name.toLowerCase();
			var nameB = b.name.toLowerCase();
			return (nameA < nameB) ? -1 : (nameA > nameB) ? 1 : 0;
		});
		setTemplateList(list)
		if (reselectTemplate)
			setSelectedTemplate(reselectTemplate)
	}, [templates,selectedTemplate,templatesImport]);
	useEffect(() => {
		if (!addDeleteTemplate)
			return
		setSelectedTemplate("")
		setAddDeleteTemplate(false)
	}, [addDeleteTemplate]);

	const updateTemplateDB = async () => {
		setNewTemplateName(undefined);
		setTemplates((prevState) => {
			var newState = {
				...prevState
			}
			for (let i=0;i<templateList.length;i++) {
				const template = templateList[i]
				const name = template.nameNew
				const nameBack = template.nameBack

				if (name === undefined || nameBack === undefined)
					continue
				// if template has been renamed, delete old entry, make sure to reselect 
				// current entry after
				if (name != nameBack) {
					newState[name] = prevState[nameBack]
					delete newState[nameBack]
				}

				// if no changes, skip
				if (newState[name] == prevState[name])
					continue

				newState[name] = {
					"sysPre": template.affixes.sysPre,
					"sysSuf": template.affixes.sysSuf,
					"instPre": template.affixes.instPre,
					"instSuf": template.affixes.instSuf,
				}
			}
			return { ...newState }
		})
	}
	useEffect(() => {
		updateTemplateDB()
	}, [isOpen, selectedTemplate]);

	const exportTemplates = () => {
		exportText(`instruct_templates.json`, JSON.stringify(templates));
	};
	const importTemplates = async (importDefaults=false) => {
		if (importDefaults) {
			if (!window.confirm("This will add all default templates, and overwrite any changes you made to the default templates. This action cannot be undone. Do you wish to continue?"))
				return;
			await templateStorage.saveTemplates(defaultPresets.instructTemplates,true)
			window.location.reload()
			// a little dirty, but updateTemplateList isn't cooperating
			return
		}
		const fileInput = document.createElement("input");
		fileInput.type = 'file';
		fileInput.style.display = 'none';
		fileInput.onchange = (e) => {
			const file = e.target.files[0];
			if (!file)
				return;
			const reader = new FileReader();
			reader.onload = (e) => {
				const contents = e.target.result;
				fileInput.func(contents);
			}
			reader.readAsText(file);
		}
		fileInput.func = async (text) => {
			await templateStorage.saveTemplates(JSON.parse(text),true)
			window.location.reload()
			// a little dirty, but updateTemplateList isn't cooperating
		};
		document.body.appendChild(fileInput);
		fileInput.click();
		document.body.removeChild(fileInput);
	};

	return getArrObjByName(templateList,selectedTemplate) && html`
		<${Modal} isOpen=${isOpen} onClose=${closeModal}
			title="Instruct Templates"
			description="Use placeholders to insert the selected prompt template formats when sending your prompt to the model.
			Placeholders are listed below. You can insert newlines with '\\n'.
			When Chat Mode is active, the 'Instruct Suffix' field of the current template will be added at the end of your prompt, before it is processed by the model. Similarly, the 'Instruct Prefix' field will be added at the end of the model's response.">
			<div id="advancedContextPlaceholders">
				<table border="1" frame="void" rules="all">
					<thead>
					<tr>
						<th></th>
						<th>Prefix</th>
						<th>Suffix</th>
					</tr>
					</thead>
					<tbody>
					<tr>
						<th>System Prompt</th>
						<td>{sys}</td>
						<td>{/sys}</td>
					</tr>
					<tr>
						<th>Instructions</th>
						<td>{inst}</td>
						<td>{/inst}</td>
					</tr>
					</tbody>
				</table>
			</div>
			<hr/>
			<div class="instructTemplatesImportExport">
				<button
					title="Import Instruct Templates"
					disabled=${!!cancel}
					onClick=${() => importTemplates()}>
					Import
				</button>
				<button
					title="Export Instruct Templates"
					disabled=${!!cancel}
					onClick=${() => exportTemplates()}>
					Export
				</button>
				<button
					title="Re-Add Default Instruct Templates"
					disabled=${!!cancel}
					onClick=${() => importTemplates(true)}>
					Re-Add Defaults
				</button>
			</div>
			<div className="buttons instructTemplateSidebar">
				<${SelectBoxTemplate}
					id="instructModalSelect"
					label="Instruct Template"
					disabled=${!!cancel}
					value=${newTemplateName ?? selectedTemplate}
					onValueChange=${setSelectedTemplate}
					options=${templateList}/>
				<button
					title="Add Instruct Template"
					disabled=${!!cancel}
					class="hbox-button"
					onClick=${() => handleInstructTemplateAdd()}>
					New
				</button>
				<button
					title="Delete Selected Instruct Template"
					disabled=${!!cancel}
					class="hbox-button"
					onClick=${() => handleInstructTemplateDelete(selectedTemplate)}>
					Delete
				</button>
			</div>
			<hr/>
			<div class="instructmodal-edits">
				<${InputBox} label="Name"
						placeholder="Name of This Template"
						id="instructmodal-name"
						className=""
						tooltip=""
						readOnly=${!!cancel}
						value=${getArrObjByName(templateList,selectedTemplate).nameNew}
						onInput=${e => handleInstructTemplateChange(selectedTemplate,"name",e.target.value,getArrObjByName(templateList,selectedTemplate).nameBack)}
						onValueChange=${() => {}}/>

				<div className="hbox">
					<${InputBox} label="Instruct Prefix {inst}"
						placeholder="[INST]"
						className=""
						tooltip=""
						readOnly=${!!cancel}
						value=${getArrObjByName(templateList,selectedTemplate)?.affixes.instPre || ""}
						onInput=${e => handleInstructTemplateChange(selectedTemplate,"instPre",e.target.value)}
						onValueChange=${() => {}}/>

						<${InputBox} label="Instruct Suffix {/inst}"
						placeholder="[/INST]"
						className=""
						tooltip=""
						readOnly=${!!cancel}
						value=${getArrObjByName(templateList,selectedTemplate)?.affixes.instSuf || ""}
						onInput=${e => handleInstructTemplateChange(selectedTemplate,"instSuf",e.target.value)}
						onValueChange=${() => {}}/>
				</div>

				<div className="hbox">
					<${InputBox} label="System Prompt Prefix {sys}"
						placeholder="<<SYS>>\n"
						className=""
						tooltip=""
						readOnly=${!!cancel}
						value=${getArrObjByName(templateList,selectedTemplate)?.affixes.sysPre || ""}
						onInput=${e => handleInstructTemplateChange(selectedTemplate,"sysPre",e.target.value)}
						onValueChange=${() => {}}/>

						<${InputBox} label="System Prompt Suffix {/sys}"
						placeholder="<</SYS>>\n\n"
						className=""
						tooltip=""
						readOnly=${!!cancel}
						value=${getArrObjByName(templateList,selectedTemplate)?.affixes.sysSuf || ""}
						onInput=${e => handleInstructTemplateChange(selectedTemplate,"sysSuf",e.target.value)}
						onValueChange=${() => {}}/>
				</div>
			</div>


		</${Modal}>`;
}

class IndexedDBAdapter {
	constructor() {
		this.dbName = 'MikuPad';
	}

	async init() {
	}

	async openDatabase() {
		return new Promise((resolve, reject) => {
			const openRequest = indexedDB.open(this.dbName, 2);

			openRequest.onerror = () => reject(openRequest.error);
			openRequest.onsuccess = () => resolve(openRequest.result);

			openRequest.onupgradeneeded = (event) => {
				const db = event.target.result;
				for (const storeName of ["Sessions", "Templates"]) {
					if (!db.objectStoreNames.contains(storeName)) {
						db.createObjectStore(storeName);
					}
				}
			};
			openRequest.onblocked = () => console.warn('Request was blocked');
		});
	}

	async loadFromDatabase(db, storeName, key) {
		return new Promise((resolve, reject) => {
			const tx = db.transaction(storeName, 'readonly');
			const store = tx.objectStore(storeName);
			const request = store.get(key);

			request.onsuccess = () => resolve(request.result);
			request.onerror = () => reject(request.error);
		});
	}

	async loadAllFromDatabase(db, storeName) {
		return new Promise((resolve, reject) => {
			const tx = db.transaction(storeName, 'readonly');
			const store = tx.objectStore(storeName);
			const request = store.openCursor();

			let allTables = {};

			request.onsuccess = async (event) => {
				const cursor = event.target.result;
				if (cursor) {
					allTables[cursor.key] = cursor.value;
					cursor.continue();
				} else {
					resolve(allTables);
				}
			};
			request.onerror = () => reject(request.error);
		});
	}

	async saveToDatabase(db, storeName, key, data) {
		return new Promise((resolve, reject) => {
			const tx = db.transaction(storeName, 'readwrite');
			const store = tx.objectStore(storeName);
			const request = store.put(data, key);

			request.onsuccess = () => resolve();
			request.onerror = () => reject(request.error);
		});
	}

	async deleteFromDatabase(db, storeName, key) {
		return new Promise((resolve, reject) => {
			const tx = db.transaction(storeName, 'readwrite');
			const store = tx.objectStore(storeName);
			const request = store.delete(key);

			request.onsuccess = () => resolve();
			request.onerror = () => reject(request.error);
		});
	}
}

class ServerDBAdapter {
	constructor(sessionEndpoint) {
		this.sessionEndpoint = sessionEndpoint;
	}

	async init() {
		// Test connection
		const db = await this.openDatabase();
		await this.loadFromDatabase(db, "Sessions", "selectedSessionId");
	}

	async openDatabase() {
		return async (route, options) => {
			try {
				return await fetch(new URL(route, this.sessionEndpoint), {
					method: 'POST',
					headers: {
						'Content-Type': 'application/json',
					},
					body: JSON.stringify(options),
				});
			} catch (e) {
				reportError(e);
				return { ok: false, status: e.toString() };
			}
		};
	}

	async loadFromDatabase(db, storeName, key) {
		return new Promise(async (resolve, reject) => {
			const res = await db("/load", { storeName, key });
			if (!res.ok) {
				if (res.status == 404) {
					resolve(undefined);
				} else {
					reject(res.status);
				}
				return;
			}
			const { result } = await res.json();
			resolve(result);
		});
	}

	async loadAllFromDatabase(db, storeName) {
		return new Promise(async (resolve, reject) => {
			const res = await db("/all", { storeName });
			if (!res.ok) {
				reject(res.status);
				return;
			}
			const { result } = await res.json();
			resolve(result);
		});
	}

	async saveToDatabase(db, storeName, key, data) {
		return new Promise(async (resolve, reject) => {
			const res = await db("/save", { storeName, key, data });
			if (!res.ok) {
				reject(res.status);
				return;
			}
			const { result } = await res.json();
			resolve(result);
		});
	}

	async deleteFromDatabase(db, storeName, key) {
		return new Promise(async (resolve, reject) => {
			const res = await db("/delete", { storeName, key });
			if (!res.ok) {
				reject(res.status);
				return;
			}
			resolve();
		});
	}
}

class AbstractStorage extends EventTarget {
	constructor(storeName, dbAdapter) {
		super();
		this.storeName = storeName;
		this.dbAdapter = dbAdapter;
		this.saveQueue = [];
		this.saveTimer = undefined;
	}

	dispatchChangeEvent() {
		this.dispatchEvent(new CustomEvent('change'));
	}

	dispatchErrorEvent(detail) {
		this.dispatchEvent(new CustomEvent('error', { detail }));
	}

	startSaveTimer(saveCallback) {
		this.saveTimer = setInterval(async () => await this.saveTimerHandler(saveCallback), 500);
	}

	async saveTimerHandler(saveCallback) {
		const keys = [];
		while (this.saveQueue.length) {
			keys.push(this.saveQueue.pop());
		}

		for (const key of keys) {
			await saveCallback(key);
		}
	}

	enqueueSave(key) {
		if (!this.saveQueue.includes(key))
			this.saveQueue.push(key);
	}

	async openDatabase() {
		try {
			return await this.dbAdapter.openDatabase();
		} catch (e) {
			this.dispatchErrorEvent(e);
			throw e;
		}
	}

	async loadFromDatabase(db, key) {
		try {
			return await this.dbAdapter.loadFromDatabase(db, this.storeName, key);
		} catch (e) {
			this.dispatchErrorEvent(e);
			throw e;
		}
	}

	async loadAllFromDatabase(db) {
		try {
			return await this.dbAdapter.loadAllFromDatabase(db, this.storeName);
		} catch (e) {
			this.dispatchErrorEvent(e);
			throw e;
		}
	}

	async saveToDatabase(db, key, data) {
		try {
			return await this.dbAdapter.saveToDatabase(db, this.storeName, key, data);
		} catch (e) {
			this.dispatchErrorEvent(e);
			throw e;
		}
	}

	async deleteFromDatabase(db, key) {
		try {
			return await this.dbAdapter.deleteFromDatabase(db, this.storeName, key);
		} catch (e) {
			this.dispatchErrorEvent(e);
			throw e;
		}
	}
}

class TemplateStorage extends AbstractStorage {
	constructor(dbAdapter) {
		super('Templates', dbAdapter);
		this.templates = {};
	}

	async init() {
		const db = await this.openDatabase();
		await this.loadTemplates(db);
	}

	async saveTemplates(newTemplates,writeOnly=false) {
		const db = await this.openDatabase();

		// Check if the keys exists in input, if not, delete
		for (const key of Object.keys(this.templates)) {
			if (Object.keys(newTemplates).includes(key))
				continue;
			if (writeOnly)
				continue;
			try {
				// If the key not in input, delete it
				await this.deleteFromDatabase(db, key);
				console.warn('Deleted key:', key);
			} catch {
				console.error('Error deleting key:', key);
			}
		}

		// put input keys
		for (const [key, value] of Object.entries(newTemplates)) {
			if (JSON.stringify(value) === JSON.stringify(this.templates[key]))
				continue;
			await this.saveToDatabase(db, key, value);
		}

		this.templates = newTemplates;
	}

	async loadTemplates(db) {
		this.templates = await this.loadAllFromDatabase(db);
	}
}

class SessionStorage extends AbstractStorage {
	constructor(dbAdapter) {
		super('Sessions', dbAdapter);
		this.nextId = undefined;
		this.sessions = {};
		this.selectedSession = undefined;

		if (dbAdapter.sessionEndpoint) {
			this.sessionEndpoint = dbAdapter.sessionEndpoint;
			this.proxyEndpoint = `${dbAdapter.sessionEndpoint}/proxy`;
		}
	}

	dispatchSessionChangeEvent() {
		this.dispatchEvent(new CustomEvent('sessionchange'));
	}

	async init() {
		const db = await this.openDatabase();
		this.nextId = (await this.loadFromDatabase(db, 'nextSessionId')) || 0;
		this.selectedSession = (await this.loadFromDatabase(db, 'selectedSessionId')) || 0;
		await this.loadSessions(db);
		this.startSaveTimer((sessionId) => this.saveSessionToDB(sessionId));
	}

	async saveSessionToDB(sessionId) {
		if (!this.sessions[sessionId])
			return;
		const db = await this.openDatabase();
		await this.saveToDatabase(db, sessionId, this.sessions[sessionId]);
	}

	async getNewId() {
		const db = await this.openDatabase();
		await this.saveToDatabase(db, 'nextSessionId', this.nextId + 1);
		this.nextId += 1;
		return this.nextId - 1;
	}

	// We leave the localStorage content untouched for now,
	// but we might want to erase it in the future.
	async migrateSessions() {
		const nextId = +localStorage.getItem('nextSessionId');
		if (nextId == 0)
			return false;
		this.nextId = nextId;
		this.selectedSession = +localStorage.getItem('selectedSessionId');
		for (const key of Object.keys(localStorage)) {
			const [sessionId, propertyName] = key.split('/');
			if (propertyName === undefined) continue;
			let value = localStorage.getItem(key);
			try {
				value = JSON.parse(value);
			} catch {
				// This might have been added to the localStorage by a extension rather than us. Let's just skip it.
				continue;
			}
			if (value !== null) {
				this.sessions[sessionId] = this.sessions[sessionId] || {};
				this.sessions[sessionId][propertyName] = value;
			}
		};
		const db = await this.openDatabase();
		await this.saveToDatabase(db, 'nextSessionId', this.nextId);
		await this.saveToDatabase(db, 'selectedSessionId', this.selectedSession);
		for (const sessionId of Object.keys(this.sessions)) {
			await this.saveToDatabase(db, +sessionId, this.sessions[sessionId]);
		}
		return true;
	}

	async loadSessions(db) {
		const sessions = await this.loadAllFromDatabase(db);
		for (const [key, value] of Object.entries(sessions)) {
			if (key !== 'nextSessionId' && key !== 'selectedSessionId') {
				this.sessions[key] = value;
			}
		}
		if (Object.keys(this.sessions).length === 0) {
			if (!await this.migrateSessions()) {
				await this.createSession('MikuPad #1');
			}
		}
		await this.switchSession(this.selectedSession);
	}

	getProperty(propertyName) {
		return this.sessions[this.selectedSession]?.[propertyName];
	}

	setProperty(propertyName, value) {
		if (!this.sessions[this.selectedSession])
			return;
		this.sessions[this.selectedSession][propertyName] = value;
		this.enqueueSave(this.selectedSession);
	}

	async switchSession(sessionId) {
		if (!this.sessions[sessionId])
			return;
		
		const db = await this.openDatabase();
		await this.saveToDatabase(db, 'selectedSessionId', +sessionId);

		this.selectedSession = +sessionId;

		this.dispatchChangeEvent();
		this.dispatchSessionChangeEvent();
	}

	async renameSession(sessionId, renameSessionName) {
		this.sessions[sessionId]['name'] = renameSessionName;

		const db = await this.openDatabase();
		await this.saveToDatabase(db, sessionId, this.sessions[sessionId]);

		this.dispatchChangeEvent();
	}

	async deleteSession(sessionId) {
		if (Object.keys(this.sessions).length === 1)
			return;
		if (!window.confirm("Are you sure you want to delete this session? This action can't be undone."))
			return;

		const db = await this.openDatabase();
		await this.deleteFromDatabase(db, sessionId);

		// Select another session if the current was deleted
		if (sessionId == this.selectedSession) {
			const sessionIds = Object.keys(this.sessions).map(x => +x);
			const sessionIdx = sessionIds.indexOf(sessionId);
			const newSessionId = sessionIds[sessionIdx - 1] ?? sessionIds[sessionIdx + 1];
			await this.switchSession(+newSessionId)
		}

		delete this.sessions[sessionId];
		this.dispatchChangeEvent();
	}

	async createSession(newSessionName) {
		const newId = await this.getNewId();
		this.sessions[newId] = { name: newSessionName };
		
		const db = await this.openDatabase();
		await this.saveToDatabase(db, newId, this.sessions[newId]);

		onchange?.();
		return newId;
	}

	async createSessionFromObject(obj, cloned) {
		const newId = await this.getNewId();
		this.sessions[newId] = {};

		for (const [propertyName, value] of Object.entries(obj)) {
			if (propertyName === 'darkMode') continue;
			this.sessions[newId][propertyName] = JSON.parse(value);
		}

		if (!this.sessions[newId].hasOwnProperty('name')) {
			this.sessions[newId]['name'] = `MikuPad #${this.nextId + 1}`;
		}

		if (cloned && !this.sessions[newId]['name'].startsWith('Cloned')) {
			this.sessions[newId]['name'] = `Cloned ${this.sessions[newId]['name']}`;
		}

		const db = await this.openDatabase();
		await this.saveToDatabase(db, newId, this.sessions[newId]);

		onchange?.();
		return newId;
	}
}

const defaultPrompt = `[INST] <<SYS>>
You are a talented writing assistant. Always respond by incorporating the instructions into expertly written prose that is highly detailed, evocative, vivid and engaging.
<</SYS>>

Write a story about Hatsune Miku and Kagamine Rin. [/INST]  Sure, how about this:

Chapter 1
`;

const defaultPresets = {
	endpoint: 'http://127.0.0.1:8080',
	endpointAPI: 0,
	endpointAPIKey: '',
	endpointModel: '',
	prompt: [{ type: 'user', content: defaultPrompt }],
	seed: -1,
	maxPredictTokens: -1,
	temperature: 0.7,
	dynaTempRange: 0,
	dynaTempExp: 1,
	repeatPenalty: 1.1,
	repeatLastN: 256,
	penalizeNl: false,
	presencePenalty: 0,
	frequencyPenalty: 0,
	topK: 40,
	topP: 0.95,
	typicalP: 1,
	minP: 0,
	tfsZ: 1,
	mirostat: 0,
	mirostatTau: 5.0,
	mirostatEta: 0.1,
	stoppingStrings: "[]",
	ignoreEos: false,
	openaiPresets: false,
	contextLength: 4096,
	tokenRatio: 3.3,
	memoryTokens: ({ "contextOrder":"{memPrefix}{wiPrefix}{wiText}{wiSuffix}{memText}{memSuffix}{prompt}","prefix":"", "text":"", "suffix":""}),
	authorNoteTokens: ({ "prefix":"", "text":"", "suffix":""}),
	authorNoteDepth: 3,
	worldInfo:({
		"mikuPediaVersion": 1,
		"entries": [],
		"prefix": "",
		"suffix": ""
	}),
	logitBias:{ bias:{},model:"none" },
	instructTemplates:{
		'Alpaca': {
			'sysPre' : '### System:\\n',
			'sysSuf' : '',
			'instPre': '\\n\\n### Instruction:\\n',
			'instSuf': '\\n\\n### Response:',
		},
		'Mistral': {
			'sysPre' : '<<SYS>>\\n',
			'sysSuf' : '<</SYS>>\\n\\n',
			'instPre': '[INST]',
			'instSuf': '[/INST]',
		},
		'ChatML': {
			'sysPre' : '<|im_start|>system\\n',
			'sysSuf' : '',
			'instPre': '<|im_end|>\\n<|im_start|>user\\n',
			'instSuf': '<|im_end|>\\n<|im_start|>assistant\\n',
		},
		'Llama 3': {
			'sysPre' : '<|start_header_id|>system<|end_header_id|>\\n\\n',
			'sysSuf' : '',
			'instPre': '<|eot_id|><|start_header_id|>user<|end_header_id|>\\n\\n',
			'instSuf': '<|eot_id|><|start_header_id|>assistant<|end_header_id|>\\n\\n',
		},
		'Phi 2': {
			'sysPre' : '',
			'sysSuf' : '',
			'instPre': '\\nInstruct: ',
			'instSuf': '\\nOutput: ',
		},
		'Phi 3': {
			'sysPre' : '<|system|>\\n',
			'sysSuf' : '',
			'instPre': '<|end|>\\n<|user|>\\n',
			'instSuf': '<|end|>\\n<|assistant|>\\n',
		},
		'Command-R': {
			'sysPre' : '<|START_OF_TURN_TOKEN|><|SYSTEM_TOKEN|>',
			'sysSuf' : '',
			'instPre': '<|END_OF_TURN_TOKEN|><|START_OF_TURN_TOKEN|><|USER_TOKEN|>',
			'instSuf': '<|END_OF_TURN_TOKEN|><|START_OF_TURN_TOKEN|><|CHATBOT_TOKEN|>',
		},
		'Metharme': {
			'sysPre' : '<|system|>',
			'sysSuf' : '',
			'instPre': '<|user|>',
			'instSuf': '<|model|>',
		},
		'Vicuna': {
			'sysPre' : '',
			'sysSuf' : '\\n\\n',
			'instPre': '\\nUSER: ',
			'instSuf': '\\nASSISTANT: ',
		},
		'Gemma': {
			'sysPre' : '',
			'sysSuf' : '',
			'instPre': '\\n<end_of_turn><start_of_turn>user\\n',
			'instSuf': '\\n<end_of_turn><start_of_turn>model\\n',
		},
	},
	scrollTop: 0
};

function joinPrompt(prompt) {
	return prompt.map(p => p.content).join('');
}

function replaceUnprintableBytes(inputString) {
	// Define a regular expression to match unprintable bytes
	const unprintableBytesRegex = /[\0-\x1F\x7F-\x9F\xAD\u0378\u0379\u037F-\u0383\u038B\u038D\u03A2\u0528-\u0530\u0557\u0558\u0560\u0588\u058B-\u058E\u0590\u05C8-\u05CF\u05EB-\u05EF\u05F5-\u0605\u061C\u061D\u06DD\u070E\u070F\u074B\u074C\u07B2-\u07BF\u07FB-\u07FF\u082E\u082F\u083F\u085C\u085D\u085F-\u089F\u08A1\u08AD-\u08E3\u08FF\u0978\u0980\u0984\u098D\u098E\u0991\u0992\u09A9\u09B1\u09B3-\u09B5\u09BA\u09BB\u09C5\u09C6\u09C9\u09CA\u09CF-\u09D6\u09D8-\u09DB\u09DE\u09E4\u09E5\u09FC-\u0A00\u0A04\u0A0B-\u0A0E\u0A11\u0A12\u0A29\u0A31\u0A34\u0A37\u0A3A\u0A3B\u0A3D\u0A43-\u0A46\u0A49\u0A4A\u0A4E-\u0A50\u0A52-\u0A58\u0A5D\u0A5F-\u0A65\u0A76-\u0A80\u0A84\u0A8E\u0A92\u0AA9\u0AB1\u0AB4\u0ABA\u0ABB\u0AC6\u0ACA\u0ACE\u0ACF\u0AD1-\u0ADF\u0AE4\u0AE5\u0AF2-\u0B00\u0B04\u0B0D\u0B0E\u0B11\u0B12\u0B29\u0B31\u0B34\u0B3A\u0B3B\u0B45\u0B46\u0B49\u0B4A\u0B4E-\u0B55\u0B58-\u0B5B\u0B5E\u0B64\u0B65\u0B78-\u0B81\u0B84\u0B8B-\u0B8D\u0B91\u0B96-\u0B98\u0B9B\u0B9D\u0BA0-\u0BA2\u0BA5-\u0BA7\u0BAB-\u0BAD\u0BBA-\u0BBD\u0BC3-\u0BC5\u0BC9\u0BCE\u0BCF\u0BD1-\u0BD6\u0BD8-\u0BE5\u0BFB-\u0C00\u0C04\u0C0D\u0C11\u0C29\u0C34\u0C3A-\u0C3C\u0C45\u0C49\u0C4E-\u0C54\u0C57\u0C5A-\u0C5F\u0C64\u0C65\u0C70-\u0C77\u0C80\u0C81\u0C84\u0C8D\u0C91\u0CA9\u0CB4\u0CBA\u0CBB\u0CC5\u0CC9\u0CCE-\u0CD4\u0CD7-\u0CDD\u0CDF\u0CE4\u0CE5\u0CF0\u0CF3-\u0D01\u0D04\u0D0D\u0D11\u0D3B\u0D3C\u0D45\u0D49\u0D4F-\u0D56\u0D58-\u0D5F\u0D64\u0D65\u0D76-\u0D78\u0D80\u0D81\u0D84\u0D97-\u0D99\u0DB2\u0DBC\u0DBE\u0DBF\u0DC7-\u0DC9\u0DCB-\u0DCE\u0DD5\u0DD7\u0DE0-\u0DF1\u0DF5-\u0E00\u0E3B-\u0E3E\u0E5C-\u0E80\u0E83\u0E85\u0E86\u0E89\u0E8B\u0E8C\u0E8E-\u0E93\u0E98\u0EA0\u0EA4\u0EA6\u0EA8\u0EA9\u0EAC\u0EBA\u0EBE\u0EBF\u0EC5\u0EC7\u0ECE\u0ECF\u0EDA\u0EDB\u0EE0-\u0EFF\u0F48\u0F6D-\u0F70\u0F98\u0FBD\u0FCD\u0FDB-\u0FFF\u10C6\u10C8-\u10CC\u10CE\u10CF\u1249\u124E\u124F\u1257\u1259\u125E\u125F\u1289\u128E\u128F\u12B1\u12B6\u12B7\u12BF\u12C1\u12C6\u12C7\u12D7\u1311\u1316\u1317\u135B\u135C\u137D-\u137F\u139A-\u139F\u13F5-\u13FF\u169D-\u169F\u16F1-\u16FF\u170D\u1715-\u171F\u1737-\u173F\u1754-\u175F\u176D\u1771\u1774-\u177F\u17DE\u17DF\u17EA-\u17EF\u17FA-\u17FF\u180F\u181A-\u181F\u1878-\u187F\u18AB-\u18AF\u18F6-\u18FF\u191D-\u191F\u192C-\u192F\u193C-\u193F\u1941-\u1943\u196E\u196F\u1975-\u197F\u19AC-\u19AF\u19CA-\u19CF\u19DB-\u19DD\u1A1C\u1A1D\u1A5F\u1A7D\u1A7E\u1A8A-\u1A8F\u1A9A-\u1A9F\u1AAE-\u1AFF\u1B4C-\u1B4F\u1B7D-\u1B7F\u1BF4-\u1BFB\u1C38-\u1C3A\u1C4A-\u1C4C\u1C80-\u1CBF\u1CC8-\u1CCF\u1CF7-\u1CFF\u1DE7-\u1DFB\u1F16\u1F17\u1F1E\u1F1F\u1F46\u1F47\u1F4E\u1F4F\u1F58\u1F5A\u1F5C\u1F5E\u1F7E\u1F7F\u1FB5\u1FC5\u1FD4\u1FD5\u1FDC\u1FF0\u1FF1\u1FF5\u1FFF\u200B-\u200F\u202A-\u202E\u2060-\u206F\u2072\u2073\u208F\u209D-\u209F\u20BB-\u20CF\u20F1-\u20FF\u218A-\u218F\u23F4-\u23FF\u2427-\u243F\u244B-\u245F\u2700\u2B4D-\u2B4F\u2B5A-\u2BFF\u2C2F\u2C5F\u2CF4-\u2CF8\u2D26\u2D28-\u2D2C\u2D2E\u2D2F\u2D68-\u2D6E\u2D71-\u2D7E\u2D97-\u2D9F\u2DA7\u2DAF\u2DB7\u2DBF\u2DC7\u2DCF\u2DD7\u2DDF\u2E3C-\u2E7F\u2E9A\u2EF4-\u2EFF\u2FD6-\u2FEF\u2FFC-\u2FFF\u3040\u3097\u3098\u3100-\u3104\u312E-\u3130\u318F\u31BB-\u31BF\u31E4-\u31EF\u321F\u32FF\u4DB6-\u4DBF\u9FCD-\u9FFF\uA48D-\uA48F\uA4C7-\uA4CF\uA62C-\uA63F\uA698-\uA69E\uA6F8-\uA6FF\uA78F\uA794-\uA79F\uA7AB-\uA7F7\uA82C-\uA82F\uA83A-\uA83F\uA878-\uA87F\uA8C5-\uA8CD\uA8DA-\uA8DF\uA8FC-\uA8FF\uA954-\uA95E\uA97D-\uA97F\uA9CE\uA9DA-\uA9DD\uA9E0-\uA9FF\uAA37-\uAA3F\uAA4E\uAA4F\uAA5A\uAA5B\uAA7C-\uAA7F\uAAC3-\uAADA\uAAF7-\uAB00\uAB07\uAB08\uAB0F\uAB10\uAB17-\uAB1F\uAB27\uAB2F-\uABBF\uABEE\uABEF\uABFA-\uABFF\uD7A4-\uD7AF\uD7C7-\uD7CA\uD7FC-\uF8FF\uFA6E\uFA6F\uFADA-\uFAFF\uFB07-\uFB12\uFB18-\uFB1C\uFB37\uFB3D\uFB3F\uFB42\uFB45\uFBC2-\uFBD2\uFD40-\uFD4F\uFD90\uFD91\uFDC8-\uFDEF\uFDFE\uFDFF\uFE1A-\uFE1F\uFE27-\uFE2F\uFE53\uFE67\uFE6C-\uFE6F\uFE75\uFEFD-\uFF00\uFFBF-\uFFC1\uFFC8\uFFC9\uFFD0\uFFD1\uFFD8\uFFD9\uFFDD-\uFFDF\uFFE7\uFFEF-\uFFFB\uFFFE\uFFFF]/g;

	// Replace unprintable bytes with their character codes
	const replacedString = inputString.replace(unprintableBytesRegex, (match) => {
		const charCode = match.charCodeAt(0);
		return `<0x${charCode.toString(16).toUpperCase().padStart(2, '0')}>`;
	});

	return replacedString;
}

function useSessionState(sessionStorage, name, initialState) {
	const savedState = useMemo(() => {
		try {
			return sessionStorage.getProperty(name);
		} catch (e) {
			reportError(e);
			return null;
		}
	}, []);

	const [value, setValue] = useState(savedState ?? initialState);

	useEffect(() => {
		function deepCopy(value) {
			return JSON.parse(JSON.stringify(value));
		}
		function onSessionChange() {
			setValue(sessionStorage.getProperty(name) ?? deepCopy(initialState));
		}

		sessionStorage.addEventListener('sessionchange', onSessionChange);
		return () => sessionStorage.removeEventListener('sessionchange', onSessionChange);
	}, []);

	const updateState = (newValue) => {
		setValue((prevValue) => {
			const updatedValue = typeof newValue === 'function' ? newValue(prevValue) : newValue;
			sessionStorage.setProperty(name, updatedValue);
			return updatedValue;
		});
	};

	return [value, updateState];
}

function useDBTemplates(templateStorage, initialState) {
	const savedState = useMemo(() => templateStorage.templates, []);

	const [value, setValue] = useState(Object.keys(savedState).length === 0 ? initialState : savedState);

	const updateState = (newValue) => {
		setValue((prevValue) => {
			const updatedValue = typeof newValue === 'function' ? newValue(prevValue) : newValue;
			templateStorage.saveTemplates(updatedValue)
			return updatedValue;
		});
	};

	return [value, updateState];
}

function usePersistentState(name, initialState) {
	const savedState = useMemo(() => {
		try {
			return JSON.parse(localStorage.getItem(name));
		} catch (e) {
			reportError(e);
			return null;
		}
	}, []);

	const [value, setValue] = useState(savedState ?? initialState);

	const updateState = (newValue) => {
		setValue((prevValue) => {
			const updatedValue = typeof newValue === 'function' ? newValue(prevValue) : newValue;
			localStorage.setItem(name, JSON.stringify(updatedValue));
			return updatedValue;
		});
	};

	return [value, updateState];
}

export function App({ sessionStorage, templateStorage, useSessionState, useDBTemplates, isMikupadEndpoint }) {
	const promptArea = useRef();
	const promptOverlay = useRef();
	const undoStack = useRef([]);
	const redoStack = useRef([]);
	const probsDelayTimer = useRef();
	const keyState = useRef({});
	const sessionReconnectTimer = useRef();
	const useScrollSmoothing = useRef(true);
	const [templates, setTemplates] = useDBTemplates(defaultPresets.instructTemplates);
	const [templateReplacements, setTemplateReplacements] = useState(false);
	const [templatesImport, setTemplatesImport] = useState(false);
	const [selectedTemplate, setSelectedTemplate] = useSessionState('template', "Llama 3");
	const [chatMode, setChatMode] = useSessionState('chatMode', false);
	const [templateList, setTemplateList] = useState([]);
	const [currentPromptChunk, setCurrentPromptChunk] = useState(undefined);
	const [undoHovered, setUndoHovered] = useState(false);
	const [showProbs, setShowProbs] = useState(true);
	const [cancel, setCancel] = useState(null);
	const [spellCheck, setSpellCheck] = usePersistentState('spellCheck', false);
	const [attachSidebar, setAttachSidebar] = usePersistentState('attachSidebar', false);
	const [showProbsMode, setShowProbsMode] = usePersistentState('showProbsMode', 0);
	const [highlightGenTokens, setHighlightGenTokens] = usePersistentState('highlightGenTokens', true);
	const [preserveCursorPosition, setPreserveCursorPosition] = usePersistentState('preserveCursorPosition', true);
	const [promptAreaWidth, setPromptAreaWidth] = usePersistentState('promptAreaWidth', undefined);
	const [theme, setTheme] = usePersistentState('theme', 0);
	const [sessionEndpointConnecting, setSessionEndpointConnecting] = useState(false);
	const [sessionEndpointError, setSessionEndpointError] = useState(undefined);
	const [showAPIKey, setShowAPIKey] = useState(false);
	const [endpoint, setEndpoint] = useSessionState('endpoint', defaultPresets.endpoint);
	const [endpointAPI, setEndpointAPI] = useSessionState('endpointAPI', defaultPresets.endpointAPI);
	const [endpointAPIKey, setEndpointAPIKey] = useSessionState('endpointAPIKey', defaultPresets.endpointAPIKey);
	const [endpointModel, setEndpointModel] = useSessionState('endpointModel', defaultPresets.endpointModel);
	const [promptChunks, setPromptChunks] = useSessionState('prompt', defaultPresets.prompt);
	const [seed, setSeed] = useSessionState('seed', defaultPresets.seed);
	const [maxPredictTokens, setMaxPredictTokens] = useSessionState('maxPredictTokens', defaultPresets.maxPredictTokens);
	const [temperature, setTemperature] = useSessionState('temperature', defaultPresets.temperature);
	const [dynaTempRange, setDynaTempRange] = useSessionState('dynaTempRange', defaultPresets.dynaTempRange);
	const [dynaTempExp, setDynaTempExp] = useSessionState('dynaTempExp', defaultPresets.dynaTempExp);
	const [repeatPenalty, setRepeatPenalty] = useSessionState('repeatPenalty', defaultPresets.repeatPenalty);
	const [repeatLastN, setRepeatLastN] = useSessionState('repeatLastN', defaultPresets.repeatLastN);
	const [penalizeNl, setPenalizeNl] = useSessionState('penalizeNl', defaultPresets.penalizeNl);
	const [presencePenalty, setPresencePenalty] = useSessionState('presencePenalty', defaultPresets.presencePenalty);
	const [frequencyPenalty, setFrequencyPenalty] = useSessionState('frequencyPenalty', defaultPresets.frequencyPenalty);
	const [topK, setTopK] = useSessionState('topK', defaultPresets.topK);
	const [topP, setTopP] = useSessionState('topP', defaultPresets.topP);
	const [typicalP, setTypicalP] = useSessionState('typicalP', defaultPresets.typicalP);
	const [minP, setMinP] = useSessionState('minP', defaultPresets.minP);
	const [tfsZ, setTfsZ] = useSessionState('tfsZ', defaultPresets.tfsZ);
	const [mirostat, setMirostat] = useSessionState('mirostat', defaultPresets.mirostat);
	const [mirostatTau, setMirostatTau] = useSessionState('mirostatTau', defaultPresets.mirostatTau);
	const [mirostatEta, setMirostatEta] = useSessionState('mirostatEta', defaultPresets.mirostatEta);
	const [ignoreEos, setIgnoreEos] = useSessionState('ignoreEos', defaultPresets.ignoreEos);
	const [openaiPresets, setOpenaiPresets] = useSessionState('openaiPresets', defaultPresets.openaiPresets);
	const [rejectedAPIKey, setRejectedAPIKey] = useState(false);
	const [openaiModels, setOpenaiModels] = useState([]);
	const [nKeepTimeout, setNKeepTimeout] = useState(false);
	const [nKeep, setNKeep] = useState(0);
	const [tokens, setTokens] = useState(0);
	const [predictStartTokens, setPredictStartTokens] = useState(0);
	const [lastError, setLastError] = useState(undefined);
	const [stoppingStrings, setStoppingStrings] = useSessionState('stoppingStrings', defaultPresets.stoppingStrings);
	const [stoppingStringsError, setStoppingStringsError] = useState(undefined);
	const [savedScrollTop, setSavedScrollTop] = useSessionState('scrollTop', defaultPresets.scrollTop);
	const [modalState, setModalState] = useState({});
	const [logitBias, setLogitBias] = useSessionState('logitBias', defaultPresets.logitBias);
	const [logitBiasParam, setLogitBiasParam] = useState({});
	const [contextLength, setContextLength] = useSessionState('contextLength', defaultPresets.contextLength);
	const [memoryTokens, setMemoryTokens] = useSessionState('memoryTokens', defaultPresets.memoryTokens);
	const [authorNoteTokens, setAuthorNoteTokens] = useSessionState('authorNoteTokens', defaultPresets.authorNoteTokens);
	const [authorNoteDepth, setAuthorNoteDepth] = useSessionState('authorNoteDepth', defaultPresets.authorNoteDepth);
	const [worldInfo, setWorldInfo] = useSessionState('worldInfo', defaultPresets.worldInfo);


	function replacePlaceholders(string,placeholders) {
		return string.replace(/\{[^}]+\}/g, function (placeholder) {
			return placeholders.hasOwnProperty(placeholder)
				? placeholders[placeholder]
				: placeholder;
		}).replace(/\\n/g, '\n')
	};
	useMemo(() => {
		setTemplateReplacements({
			"{inst}": templates[selectedTemplate]?.instPre && templates[selectedTemplate]?.instPre !== ""
				? templates[selectedTemplate]?.instPre
				: "",
			"{/inst}": templates[selectedTemplate]?.instSuf && templates[selectedTemplate]?.instSuf !== ""
				? templates[selectedTemplate]?.instSuf
				: "",
			"{sys}": templates[selectedTemplate]?.sysPre && templates[selectedTemplate]?.sysPre !== ""
				? templates[selectedTemplate]?.sysPre
				: "",
			"{/sys}": templates[selectedTemplate]?.sysSuf && templates[selectedTemplate]?.sysSuf !== ""
				? templates[selectedTemplate]?.sysSuf
				: "",
		})
	}, [selectedTemplate,templates])

	// AN and Memory
	function handleauthorNoteTokensChange(key,value) {
		setAuthorNoteTokens((prevauthorNoteTokens) => ({ ...prevauthorNoteTokens, [key]: value }));
	}
	// token counts for an
	useEffect(() => {
		setNKeepTimeout(false)
		const order = ["prefix","text","suffix"]
		const assembled = authorNoteTokens.text && authorNoteTokens.text !== ""
			? order.map(key => authorNoteTokens[key]).join("")
			: "";	
		if (assembled == "" || endpointAPI == 3) {
			setAuthorNoteTokens((prevauthorNoteTokens) => ({ ...prevauthorNoteTokens, "tokens": 0 }))
			return
		}
		const ac = new AbortController();
		const to = setTimeout(async () => {
			try {
				const tokenCount = await getTokenCount({
					endpoint,
					endpointAPI,
					...(endpointAPI == 3 || endpointAPI == 0 ? { endpointAPIKey } : {}),
					content: `${replacePlaceholders(assembled,templateReplacements)}`,
					signal: ac.signal,
					...(isMikupadEndpoint ? { proxyEndpoint: sessionStorage.proxyEndpoint } : {})
				});
				setAuthorNoteTokens((prevauthorNoteTokens) => ({
					...prevauthorNoteTokens,
					"tokens": tokenCount - 1 
				}));
			} catch (e) {
				if (e.name !== 'AbortError'){
					reportError(e);
					setNKeepTimeout(true)
					setAuthorNoteTokens((prevauthorNoteTokens) => ({ ...prevauthorNoteTokens, "tokens": 0 }))
				}	
			}
		}, 500);

		ac.signal.addEventListener('abort', () => clearTimeout(to));
		return () => ac.abort();
	},[authorNoteTokens.text,authorNoteTokens.prefix,authorNoteTokens.suffix,cancel,endpoint,endpointAPI])

	function handleMemoryTokensChange(key,value) {
		setMemoryTokens((prevMemoryTokens) => ({ ...prevMemoryTokens, [key]: value }));
	}
	// token counts for memory
	useEffect(() => {
		setNKeepTimeout(false)
		const order = ["prefix","text","suffix"]
		const assembled = memoryTokens.text && memoryTokens.text !== ""
			? order.map(key => memoryTokens[key]).join("")
			: "";	
		if (assembled == "" || endpointAPI == 3){
			setMemoryTokens((prevMemoryTokens) => ({ ...prevMemoryTokens, "tokens": 0 }));
			return
		}

		const ac = new AbortController();
		const to = setTimeout(async () => {
			try {
				const tokenCount = await getTokenCount({
					endpoint,
					endpointAPI,
					...(endpointAPI == 3 || endpointAPI == 0 ? { endpointAPIKey } : {}),
					content: `${replacePlaceholders(assembled,templateReplacements)}`,
					signal: ac.signal,
					...(isMikupadEndpoint ? { proxyEndpoint: sessionStorage.proxyEndpoint } : {})
				});
				setMemoryTokens((prevMemoryTokens) => ({
					...prevMemoryTokens,
					"tokens": tokenCount - 1 
				}));
			} catch (e) {
				if (e.name !== 'AbortError'){
					reportError(e);
					setNKeepTimeout(true)
					setMemoryTokens((prevMemoryTokens) => ({ ...prevMemoryTokens, "tokens": 0 }));
				}
			}
		}, 500);

		ac.signal.addEventListener('abort', () => clearTimeout(to));
		return () => ac.abort();
	},[memoryTokens.text,memoryTokens.prefix,memoryTokens.suffix,cancel,endpoint,endpointAPI])
	// token counts for wi
	useEffect(() => {
		setNKeepTimeout(false)
		const assembled = memoryTokens.worldInfo && memoryTokens.worldInfo !== ""
			? [worldInfo.prefix,memoryTokens.worldInfo,worldInfo.suffix].join("")
			: "";
		if (assembled == "" || endpointAPI == 3){
			setMemoryTokens((prevMemoryTokens) => ({ ...prevMemoryTokens, "tokensWI": 0 }));
			return
		}

		const ac = new AbortController();
		const to = setTimeout(async () => {
			try {
				const tokenCount = await getTokenCount({
					endpoint,
					endpointAPI,
					...(endpointAPI == 3 || endpointAPI == 0 ? { endpointAPIKey } : {}),
					content: `${replacePlaceholders(assembled,templateReplacements)}`,
					signal: ac.signal,
					...(isMikupadEndpoint ? { proxyEndpoint: sessionStorage.proxyEndpoint } : {})
				});
				setMemoryTokens((prevMemoryTokens) => ({
					...prevMemoryTokens,
					"tokensWI": tokenCount - 1 
				}));
			} catch (e) {
				if (e.name !== 'AbortError'){
					reportError(e);
					setNKeepTimeout(true)
					setMemoryTokens((prevMemoryTokens) => ({ ...prevMemoryTokens, "tokensWI": 0 }));
				}
			}
		}, 500);

		ac.signal.addEventListener('abort', () => clearTimeout(to));
		return () => ac.abort();
	},[worldInfo.prefix,memoryTokens.worldInfo,worldInfo.suffix,cancel,endpoint,endpointAPI])



	const insertTemplate = (sysInst) => {
		// most of this function is shamelessly stolen from culturedniichan's deleted pull
		// request for a similar implementation of instruct templates:
		// https://github.com/lmg-anon/mikupad/pull/31

		const [prefix,suffix] = sysInst == "sys"
		? [templates[selectedTemplate]?.sysPre  || "", templates[selectedTemplate]?.sysSuf  || ""]
		: [templates[selectedTemplate]?.instPre || "", templates[selectedTemplate]?.instSuf || ""];
		if (!(prefix || suffix))
			return;

		const elem = promptArea.current;
		if (!elem)
			return;

		const startPos = elem.selectionStart;
		const endPos = elem.selectionEnd;
		const textBefore = elem.value.substring(0, startPos) || "";
		const textAfter = elem.value.substring(endPos);
		const selectedText = elem.value.substring(startPos, endPos);

		const finalText = textBefore 
						+ prefix.replace(/\\n/g,'\n')
						+ selectedText 
						+ suffix.replace(/\\n/g,'\n')
						+ textAfter;

		elem.value = finalText;

		let newCursorPos;
		if (selectedText.length === 0) {
			newCursorPos = startPos + prefix.length;
		} else {
			newCursorPos = startPos 
				+ prefix.length
				+ selectedText.length 
				+ suffix.length;
		}
		elem.setSelectionRange(0, 2);
		onInput({ target: elem });
	}

	const toggleModal = (modalKey) => {
		setModalState((prevState) => ({
			...prevState,
			[modalKey]: !prevState[modalKey],
		}));
	};
	const closeModal = (modalKey) => {
		setModalState((prevState) => ({
			...prevState,
			[modalKey]: false,
		}));
	};


	const promptText = useMemo(() => joinPrompt(promptChunks), [promptChunks]);

	// compute separately as I imagine this can get expensive
	const assembledWorldInfo = useMemo(() => {
		// assemble non-empty wi
		const validWorldInfo = !Array.isArray(worldInfo.entries) ? [] : worldInfo.entries.filter(entry =>
			entry.keys.length > 0 && !(entry.keys.length == 1 && entry.keys[0] == "") && entry.text !== "");

		// search prompt
		const activeWorldInfo = validWorldInfo.filter(entry => {
			if (validWorldInfo.length < 1) { return }
			// default to 2048
			const searchRange = isNaN(entry.search) || entry.search === ""
				? 2048
				: Number(entry.search);

			// truncate to search range. using promptText allows for search ranges larger than context
			const searchPrompt = promptText.substring(promptText.length - searchRange * defaultPresets.tokenRatio);

			// search in range
			return entry.keys.some((key, index) => {
				// don't waste resources on disabled entries
				if (searchPrompt.length == 0) {
					return
				}

				// an invalid regex here can completely lock you out of mikupad until you clear
				// localStorage, so this is necessary to handle that.
				try {
					return new RegExp(key, "i").test(searchPrompt) && key !== "";
				}
				catch (error) {
					console.error(`Error in RegEx for key '${key}': ${error.message}`);
					return false;
				}
			});
		});

		const assembledWorldInfo = activeWorldInfo.length > 0
			? activeWorldInfo.map(entry => entry.text).join("\n")
			: "";

		return assembledWorldInfo
	}, [worldInfo]);

	const [persistentContextTemp,promptRemainderTemp,rawPersistentContext] = useMemo(() => {
		// add world info to memory for easier assembly
		memoryTokens["worldInfo"] = assembledWorldInfo;

		const order = ["prefix","text","suffix"]
		const assembledAuthorNote = authorNoteTokens.text && authorNoteTokens.text !== ""
			? order.map(key => authorNoteTokens[key]).join("").replace(/\\n/g,'\n')
			: "";

		// replacements for the contextOrder string
		const contextReplacements = {
			"{wiPrefix}": memoryTokens.worldInfo && memoryTokens.worldInfo !== ""
				? worldInfo.prefix
				: "", // wi prefix and suffix will be added whenever wi isn't empty
			"{wiText}": memoryTokens.worldInfo,
			"{wiSuffix}": memoryTokens.worldInfo && memoryTokens.worldInfo !== ""
				? worldInfo.suffix
				: "",

			"{memPrefix}": memoryTokens.text && memoryTokens.text !== "" || memoryTokens.worldInfo !== ""
				? memoryTokens.prefix
				: "", // memory prefix and suffix will be added whenever memory or wi aren't empty
			"{memText}": memoryTokens.text,
			"{memSuffix}": memoryTokens.text && memoryTokens.text !== "" || memoryTokens.worldInfo !== ""
				? memoryTokens.suffix
				: "",
		}

		// prompt length estimation
		const additionalContext = (Object.values(contextReplacements)
			.filter(value => typeof value === 'string').join('')).length;
		const estimatedContextStart = Math.round(
			promptText.length - contextLength * defaultPresets.tokenRatio + additionalContext) + 1;

		// trunkate prompt to context limit
		const truncPrompt = promptText.substring(estimatedContextStart);
		// since we're now using n_keep for llama and kobold, we could just leave this out

		// make injection depth valid
		const truncPromptLen = truncPrompt.split('\n').length;
		const injDepth = truncPromptLen > authorNoteDepth ? authorNoteDepth : truncPromptLen

		const lines = truncPrompt.match(/.*\n?/g);
		const injIndex = lines.length-injDepth-1
		// inject an
		lines.splice(injIndex,0,assembledAuthorNote)
		// if an, return an context, else return original truncated context
		const authorNotePrompt = assembledAuthorNote != ""
			? lines.join('')
			: truncPrompt;

		// add the final replacement
		contextReplacements["{prompt}"] = authorNotePrompt

		const workingContextOrder = memoryTokens.contextOrder && memoryTokens.contextOrder !== ""
			? memoryTokens.contextOrder
			: defaultPresets.memoryTokens.contextOrder;


		const splitContextOrder = workingContextOrder.replaceAll("}{","},{").split(",")

		const contextOrderList = [
			splitContextOrder.slice(0, splitContextOrder.indexOf("{prompt}")).join(""),
			splitContextOrder.slice(splitContextOrder.indexOf("{prompt}")).join("")
		]
		const rawPersistentContext = contextOrderList[0]
		

		const contextList = contextOrderList.map(function (line) {
				return replacePlaceholders(line,contextReplacements)
			})
		
		// we split the prompt into stuff that comes before the prompt, and stuff that
		// comes after
		return [ contextList[0],contextList[1],rawPersistentContext ]
	}, [contextLength, promptText, memoryTokens, authorNoteTokens, authorNoteDepth, assembledWorldInfo, worldInfo.prefix, worldInfo.suffix]);


	// we then replace instruct templates in both
	const persistentContext = useMemo(() => {
		return replacePlaceholders(persistentContextTemp,templateReplacements)
	}, [persistentContextTemp,selectedTemplate,templates])

	const promptRemainder = useMemo(() => {
		return replacePlaceholders(promptRemainderTemp,templateReplacements)
	}, [promptRemainderTemp,selectedTemplate,templates])

	
	// and if we use an n_keep compatible backend, we get a count of all the stuff
	// before the prompt, because that's our memory, and we wanna keep that in context
	const persistentContextTokenTotal = useEffect(() => {
		if (endpointAPI == 3) // don't think ooba/openai has n_keep
			return

		if (!persistentContext || nKeepTimeout) {
			setNKeep(0)
			return
		}
		
		var calc = 0
		if (rawPersistentContext.includes("{memText}")) {
			calc += (memoryTokens?.tokens||0)
		}
		if (rawPersistentContext.includes("{wiText}")) {
			calc += (memoryTokens?.tokensWI||0)
		}
		setNKeep(calc + 1)
	}, [memoryTokens.tokens,memoryTokens.tokensWI,nKeepTimeout]);



	const modifiedPrompt = useMemo(() => {
		const finalPrompt = [persistentContext,promptRemainder].join("")

		return finalPrompt;
	}, [persistentContext, promptRemainder]);

	async function predict(prompt = modifiedPrompt, chunkCount = promptChunks.length) {
		if (cancel) {
			cancel?.();

			// llama.cpp server sometimes generates gibberish if we stop and
			// restart right away (???)
			let cancelled = false;
			setCancel(() => () => cancelled = true);
			await new Promise(resolve => setTimeout(resolve, 500));
			if (cancelled)
				return;
		}

		const ac = new AbortController();
		const cancelThis = () => {
			abortCompletion({
				endpoint,
				endpointAPI,
				...(isMikupadEndpoint ? { proxyEndpoint: sessionStorage.proxyEndpoint } : {})
			});
			ac.abort();
		};
		setCancel(() => cancelThis);
		setLastError(undefined);

		try {
			// sometimes "getTokenCount" can take a while because the server is busy
			// so let's set the predictStartTokens beforehand.
			setPredictStartTokens(tokens);

			const tokenCount = await getTokenCount({
				endpoint,
				endpointAPI,
				...(endpointAPI == 3 || endpointAPI == 0 ? { endpointAPIKey } : {}),
				content: prompt,
				signal: ac.signal,
				...(isMikupadEndpoint ? { proxyEndpoint: sessionStorage.proxyEndpoint } : {})
			});
			setTokens(tokenCount);
			setPredictStartTokens(tokenCount);

			// Chat Mode
			if (chatMode && !restartedPredict && templates[selectedTemplate]) {
				// add user EOT template (instruct suffix) if not switch completion
				const { instSuf, instPre } = templates[selectedTemplate];
				const instSufIndex = instSuf ? prompt.lastIndexOf(instSuf) : -1;
				const instPreIndex = instPre ? prompt.lastIndexOf(instPre) : -1;
				if (instSufIndex <= instPreIndex) {
					const eotUser = instSuf.replace(/\\n/g, '\n')
					setPromptChunks(p => [...p, { type: 'user', content: eotUser }])
					prompt += eotUser;
				}
			}
			setRestartedPredict(false)

			while (undoStack.current.at(-1) >= chunkCount)
				undoStack.current.pop();
			undoStack.current.push(chunkCount);
			redoStack.current = [];
			setUndoHovered(false);
			setRejectedAPIKey(false);
			promptArea.current.scrollTarget = undefined;
			useScrollSmoothing.current = true;

			for await (const chunk of completion({
				endpoint,
				endpointAPI,
				...(endpointAPI == 3 || endpointAPI == 0 ? {
					endpointAPIKey,
					model: endpointModel
				} : {}),
				prompt,
				...(seed != -1 ? { seed } : {}),
				temperature,
				...(!openaiPresets || endpointAPI != 3 ? {
					dynatemp_range: dynaTempRange,
					dynatemp_exponent: dynaTempExp,
					repeat_penalty: repeatPenalty,
					repeat_last_n: repeatLastN,
					penalize_nl: penalizeNl,
					ignore_eos: ignoreEos,
				} : {}),
				...(Object.keys(logitBias.bias).length > 0 && endpointAPI != 3 ? {
					logit_bias: logitBiasParam,
				} : {}),
				presence_penalty: presencePenalty,
				frequency_penalty: frequencyPenalty,
				...((mirostat && (!openaiPresets || endpointAPI != 3)) ? {
					mirostat,
					mirostat_tau: mirostatTau,
					mirostat_eta: mirostatEta,
				} : {
					top_p: topP,
					...(!openaiPresets || endpointAPI != 3 ? {
						top_k: topK,
						typical_p: typicalP,
						min_p: minP,
						tfs_z: tfsZ
					} : {})
				}),
				n_predict: maxPredictTokens,
				...(endpointAPI != 3 && nKeep > 0 ? {
					n_keep: nKeep,
				} : {}),
				n_probs: 10,
				...(JSON.parse(stoppingStrings).length ? { stop: JSON.parse(stoppingStrings) } : {}),
				signal: ac.signal,
				...(isMikupadEndpoint ? { proxyEndpoint: sessionStorage.proxyEndpoint } : {})
			})) {
				ac.signal.throwIfAborted();
				if (chunk.stopping_word)
					chunk.content = chunk.stopping_word;
				if (!chunk.content)
					continue;
				setPromptChunks(p => [...p, chunk]);
				setTokens(t => t + (chunk?.completion_probabilities?.length ?? 1));
				chunkCount += 1;
			}
		} catch (e) {
			if (e.name !== 'AbortError') {
				reportError(e);
				const errStr = e.toString();
				if ((endpointAPI == 3 || endpointAPI == 0) && errStr.includes("401")) {
					setLastError("Error: Rejected API Key");
					setRejectedAPIKey(true);
				} else if (endpointAPI == 3 && errStr.includes("429")) {
					setLastError("Error: Insufficient Quota");
				} else {
					setLastError(errStr);
				}
			}
			return false;
		} finally {
			setCancel(c => c === cancelThis ? null : c);
			if (undoStack.current.at(-1) === chunkCount)
				undoStack.current.pop();
		}
		// Chat Mode
		if (chatMode) {
			// add bot EOT template (instruct prefix)
			const eotBot = templates[selectedTemplate]?.instPre.replace(/\\n/g, '\n')
			setPromptChunks(p => [...p, { type: 'user', content: eotBot }])
			prompt += `${eotBot}`
		}
	}

	function undo() {
		if (!undoStack.current.length)
			return false;
		redoStack.current.push(promptChunks.slice(undoStack.current.at(-1)));
		setPromptChunks(p => p.slice(0, undoStack.current.pop()));
		return true;
	}

	function redo() {
		if (!redoStack.current.length)
			return false;
		undoStack.current.push(promptChunks.length);
		setPromptChunks(p => [...p, ...redoStack.current.pop()]);
		setUndoHovered(false);
		return true;
	}

	const [triggerPredict, setTriggerPredict] = useState(false);
	const [restartedPredict, setRestartedPredict] = useState(false);

	function undoAndPredict() {
		if (!undoStack.current.length) return;
		if (triggerPredict) return;
		const didUndo = undo();
		if (didUndo) {
			setTriggerPredict(true);
		}
	}

	function setTitleToSession() {
		const sessionName = sessionStorage.getProperty('name');
		document.title = sessionName ? 'mikupad - ' + sessionName : 'mikupad';
	}

	useEffect(() => {
		setTitleToSession();
	}, [sessionStorage]);

	useEffect(() => {
		if (triggerPredict) {
			predict();
			setTriggerPredict(false);
		}
	}, [triggerPredict]);

	useLayoutEffect(() => {
		if (attachSidebar)
			document.body.classList.add('attachSidebar');
		else
			document.body.classList.remove('attachSidebar');
	}, [attachSidebar]);

	useLayoutEffect(() => {
		if (promptAreaWidth) {
			const container = document.querySelector('#prompt-container');
			container.style.setProperty('min-width', promptAreaWidth);
			container.style.setProperty('max-width', promptAreaWidth);
		}
	}, [promptAreaWidth]);

	useLayoutEffect(() => {
		document.documentElement.classList.remove('serif-dark');
		document.documentElement.classList.remove('monospace-dark');
		document.documentElement.classList.remove('nockoffAI');
		switch (theme) {
		case 1:
			document.documentElement.classList.add('serif-dark');
			break;
		case 2:
			document.documentElement.classList.add('monospace-dark');
			break;
		case 3:
			document.documentElement.classList.add('nockoffAI');
			break;
		}
	}, [theme]);


	useEffect(() => {
		try {
			JSON.parse(stoppingStrings);
			setStoppingStringsError(undefined);
		} catch (e) {
			setStoppingStringsError(e.toString());
		}
	}, [stoppingStrings]);

	useEffect(() => {
		if (showProbsMode === -1)
			return;

		const adjustProbsPosition = () => {
			const probsElement = document.getElementById('probs');
			if (!probsElement) return;

			probsElement.style.display = '';
			probsElement.style.setProperty('--probs-top', `${currentPromptChunk.top}px`);
			probsElement.style.setProperty('--probs-left', `${currentPromptChunk.left}px`);

			const probsRect = probsElement.getBoundingClientRect();
			const viewportWidth = window.innerWidth || document.documentElement.clientWidth;
			const viewportHeight = window.innerHeight || document.documentElement.clientHeight;

			// Adjust left position if element goes off-screen on the right
			if (probsRect.right > viewportWidth) {
				const newLeft = viewportWidth - probsRect.width / 2;
				probsElement.style.setProperty('--probs-left', `${newLeft}px`);
			}

			// Adjust right position if element goes off-screen on the left
			if (probsRect.left < 0) {
				probsElement.style.setProperty('--probs-left', `${probsRect.width / 2}px`);
			}
		};

		if (currentPromptChunk && showProbs) {
			setTimeout(() => {
				adjustProbsPosition();
			});
		}
	}, [currentPromptChunk, showProbs]);

	// Update the textarea in an uncontrolled way so the user doesn't lose their
	// selection or cursor position during prediction
	useLayoutEffect(() => {
		const elem = promptArea.current;
		if (elem.value === promptText) {
			return;
		} else if (elem.value.length && promptText.startsWith(elem.value)) {
			const isTextSelected = elem.selectionStart !== elem.selectionEnd;
			const oldHeight = elem.scrollHeight;
			const atBottom = (elem.scrollTarget ?? elem.scrollTop) + elem.clientHeight + 1 > oldHeight;
			const oldLen = elem.value.length;
			// disable preserveCursorPosition in chatMode
			if ( (!isTextSelected && !preserveCursorPosition) || chatMode) {
				elem.value = promptText;
			} else {
				elem.setRangeText(promptText.slice(oldLen), oldLen, oldLen, 'preserve');
			}
			const newHeight = elem.scrollHeight;
			if (atBottom && oldHeight !== newHeight) {
				if (elem.scrollHeight - (elem.scrollTop + elem.clientHeight + 1) >= 100) {
					// smooth scroll isn't keeping up with prediction speed =(
					useScrollSmoothing.current = false;
				}
				elem.scrollTarget = newHeight - elem.clientHeight;
				elem.scrollTo({
					top: newHeight - elem.clientHeight,
					behavior: useScrollSmoothing.current ? 'smooth' : 'instant',
				});
			}
		} else {
			elem.value = promptText;
		}
	}, [promptText]);

	useLayoutEffect(() => {
		if (cancel)
			return;
		promptArea.current.scrollTarget = undefined;
		promptArea.current.scrollTop = savedScrollTop;
		promptOverlay.current.scrollTop = savedScrollTop;
	}, [savedScrollTop, highlightGenTokens, showProbsMode]);

	useEffect(() => {
		if (cancel)
			return;
		const ac = new AbortController();
		const to = setTimeout(async () => {
			try {
				const tokenCount = await getTokenCount({
					endpoint,
					endpointAPI,
					...(endpointAPI == 3 || endpointAPI == 0 ? { endpointAPIKey } : {}),
					content: modifiedPrompt,
					signal: ac.signal,
					...(isMikupadEndpoint ? { proxyEndpoint: sessionStorage.proxyEndpoint } : {})
				});
				setTokens(tokenCount);
			} catch (e) {
				if (e.name !== 'AbortError')
					reportError(e);
			}
		}, 500);
		ac.signal.addEventListener('abort', () => clearTimeout(to));
		return () => ac.abort();
	}, [modifiedPrompt, cancel, endpoint, endpointAPI]);

	useEffect(() => {
		if (endpointAPI != 3)
			return;
		setRejectedAPIKey(false);
		const ac = new AbortController();
		const to = setTimeout(async () => {
			try {
				const models = await getModels({
					endpoint,
					endpointAPI,
					...(endpointAPI == 3 ? { endpointAPIKey } : {}),
					signal: ac.signal,
					...(isMikupadEndpoint ? { proxyEndpoint: sessionStorage.proxyEndpoint } : {})
				});
				setOpenaiModels(models);
			} catch (e) {
				if (e.name !== 'AbortError') {
					reportError(e);
					const errStr = e.toString();
					if (endpointAPI == 3 && errStr.includes("401")) {
						setRejectedAPIKey(true);
					}
				}
			}
		}, 500);
		ac.signal.addEventListener('abort', () => clearTimeout(to));
		return () => ac.abort();
	}, [endpoint, endpointAPI, endpointAPIKey]);

	useEffect(() => {
		function onKeyDown(e) {
			const { altKey, ctrlKey, shiftKey, key, defaultPrevented } = e;
			if (defaultPrevented)
				return;
			switch (`${altKey}:${ctrlKey}:${shiftKey}:${key}`) {
			case 'false:false:true:Enter':
			case 'false:true:false:Enter':
				predict();
				break;
			case 'false:false:false:Escape':
				cancel();
				break;
			case 'false:true:false:r':
			case 'false:false:true:r':
				undoAndPredict();
				break;
			case 'false:true:false:z':
			case 'false:false:true:z':
				if (cancel || !undo()) return;
				break;
			case 'false:true:true:Z':
			case 'false:true:false:y':
			case 'false:false:true:y':
				if (cancel || !redo()) return;
				break;

			default:
				keyState.current = e;
				return;
			}
			e.preventDefault();
		}
		function onKeyUp(e) {
			const { altKey, ctrlKey, shiftKey, key, defaultPrevented } = e;
			if (defaultPrevented)
				return;
			keyState.current = e;
		}

		window.addEventListener('keydown', onKeyDown);
		window.addEventListener('keyup', onKeyUp);
		return () => {
			window.removeEventListener('keydown', onKeyDown);
			window.removeEventListener('keyup', onKeyUp)
		};
	}, [predict, cancel]);

	// textarea resize
	useEffect(() => {
		const container = document.querySelector('#prompt-container');

		let isDragging = false;
		let startX;
		let startMaxWidth;
		let startEdge;
		let edgeDetectionZone = 5; // Pixels from edge to trigger resize

		function getNearEdge(e) {
			const rect = container.getBoundingClientRect();
			if (e.clientX - rect.left < edgeDetectionZone && e.clientX - rect.left > 0) {
				return 'left';
			} else if (rect.right - e.clientX < edgeDetectionZone && rect.right - e.clientX > 0) {
				return 'right';
			}
			return false;
		}

		function startDragging(e) {
			const edge = getNearEdge(e);
			if (!edge) return; // Only drag from edges

			// reset selection
			promptArea.current.selectionStart = promptArea.current.selectionEnd;

			isDragging = true;

			const invEdgePos = edge == 'right' ? container.getBoundingClientRect().left : container.getBoundingClientRect().right;
			startX = e.clientX - invEdgePos;
			startMaxWidth = getComputedStyle(container).getPropertyValue('max-width');
			startEdge = edge;
		}

		function drag(e) {
			switch (getNearEdge(e)) {
				case 'right':
					promptArea.current.style.cursor = 'col-resize';
					container.style.cursor = 'col-resize';
					container.style.borderRight = '2px dotted var(--color-light)';
					break;
				case 'left':
					promptArea.current.style.cursor = 'col-resize';
					container.style.cursor = 'col-resize';
					container.style.borderLeft = '2px dotted var(--color-light)';
					break;
				default:
					promptArea.current.style.cursor = '';
					container.style.cursor = '';
					container.style.borderRight = '2px dotted transparent';
					container.style.borderLeft = '2px dotted transparent';
					break;
			}

			if (!isDragging) return;

			// reset selection
			promptArea.current.selectionStart = promptArea.current.selectionEnd;

			const invEdgePos = startEdge == 'right' ? container.getBoundingClientRect().left : container.getBoundingClientRect().right;
			const currentX = e.clientX - invEdgePos;
			setPromptAreaWidth(`calc(${startMaxWidth} + ${(currentX - startX) * (startEdge == 'right' ? 1 : -1)}px)`);
		}

		function stopDragging() {
			isDragging = false;
		}

		container.addEventListener('mousedown', startDragging);
		document.addEventListener('mousemove', drag);
		document.addEventListener('mouseup', stopDragging);
		document.addEventListener('mouseleave', stopDragging);
		return () => {
			container.removeEventListener('mousedown', startDragging);
			document.removeEventListener('mousemove', drag);
			document.removeEventListener('mouseup', stopDragging);
			document.removeEventListener('mouseleave', stopDragging);
		};
	}, []);

	function onInput({ target }) {
		setPromptChunks(oldPrompt => {
			const start = [];
			const end = [];
			const oldPromptLength = oldPrompt.length;
			oldPrompt = [...oldPrompt];
			let newValue = target.value;

			while (oldPrompt.length) {
				const chunk = oldPrompt[0];
				if (!newValue.startsWith(chunk.content))
					break;
				oldPrompt.shift();
				start.push(chunk);
				newValue = newValue.slice(chunk.content.length);
			}

			while (oldPrompt.length) {
				const chunk = oldPrompt.at(-1);
				if (!newValue.endsWith(chunk.content))
					break;
				oldPrompt.pop();
				end.unshift(chunk);
				newValue = newValue.slice(0, -chunk.content.length);
			}

			// Remove all undo positions within the modified range.
			undoStack.current = undoStack.current.filter(pos => start.length < pos);
			if (!undoStack.current.length)
				setUndoHovered(false);

			// Update all undo positions.
			if (start.length + end.length + (+!!newValue) !== oldPromptLength) {
				// Reset redo stack if a new chunk is added/removed at the end.
				if (!end.length)
					redoStack.current = [];

				if (!oldPrompt.length)
					undoStack.current = undoStack.current.map(pos => pos + 1);
				else
					undoStack.current = undoStack.current.map(pos => pos - oldPrompt.length);
			}

			const newPrompt = [
				...start,
				...(newValue ? [{ type: 'user', content: newValue }] : []),
				...end,
			];
			return newPrompt;
		});
	}

	function onScroll({ target }) {
		if (target.scrollTop === target.scrollTarget)
			target.scrollTarget = undefined;

		const newTop = target.scrollTop;
		const oldTop = promptOverlay.current.scrollTop;

		if (newTop < oldTop) {
			// user scrolled up
			target.scrollTarget = undefined;
		}

		promptOverlay.current.scrollTop = target.scrollTop;
		promptOverlay.current.scrollLeft = target.scrollLeft;
		setSavedScrollTop(newTop);

		if (showProbsMode !== -1) {
			const probsElement = document.getElementById('probs');
			if (probsElement) {
				const probsTop = getComputedStyle(probsElement).getPropertyValue('top');
				probsElement.style.setProperty('--probs-top', `calc(${probsTop} + ${oldTop - newTop}px)`);
			} else if (currentPromptChunk) {
				currentPromptChunk.top += oldTop - newTop;
			}
		}
	}

	function onPromptMouseMove({ clientX, clientY }) {
		if (showProbsMode === -1 && !highlightGenTokens)
			return;
		promptOverlay.current.style.pointerEvents = 'auto';
		const elem = document.elementFromPoint(clientX, clientY);
		const pc = elem?.closest?.('[data-promptchunk]');
		const probs = elem?.closest?.('#probs');
		promptOverlay.current.style.pointerEvents = 'none';
		if (probs)
			return;
		if (!pc) {
			setCurrentPromptChunk(undefined);
			return;
		}
		const rect = [...pc.getClientRects()].at(-1);
		const index = +pc.dataset.promptchunk;
		const top = rect.top;
		const left = rect.x + rect.width / 2;
		setCurrentPromptChunk(cur => {
			const isCurrent = cur && cur.index === index && cur.top === top && cur.left === left;
			switch (showProbsMode) {
				case 0:
					if (!isCurrent || !showProbs) {
						setShowProbs(false);
						clearTimeout(probsDelayTimer.current);
						probsDelayTimer.current = setTimeout(() => setShowProbs(true), 300);
					}
					break;
				case 1:
					setShowProbs(keyState.current.ctrlKey);
			}
			return isCurrent ? cur : { index, top, left };
		});
	}

	async function switchCompletion(i, tok) {
		const newPrompt = [
			...promptChunks.slice(0, i),
			{
				...promptChunks[i],
				content: tok,
			},
		];
		setPromptChunks(newPrompt);
		setTriggerPredict(true);
		setRestartedPredict(true);
	}

	function switchEndpointAPI(value) {
		let url;
		try {
			url = new URL(endpoint);
		} catch {
			return;
		}
		switch (value) {
			case 0: // llama.cpp
				if (url.protocol != 'http:' && url.protocol != 'https:')
					url.protocol = "http:";
				url.port = 8080;
				break;
			case 2: // koboldcpp
				if (url.protocol != 'http:' && url.protocol != 'https:')
					url.protocol = "http:";
				url.port = 5001;
				break;
			case 3:
				if (url.protocol != 'http:' && url.protocol != 'https:')
					url.protocol = "http:";
				break;
		}
		setEndpoint(url.toString());
		setEndpointAPI(value);
	}

	function isMixedContent() {
		const isHttps = window.location.protocol == 'https:';
		let url;
		try {
			url = new URL(endpoint);
		} catch {
			return false;
		}
		return isHttps && (url.protocol !== 'https:' && url.protocol !== 'wss:');
	}

	useEffect(() => {
		function onSessionChange() {
			redoStack.current = [];
			undoStack.current = [];
			setUndoHovered(false);
			setTitleToSession();
		}
		function onSessionError() {
			if (!sessionReconnectTimer.current) {
				sessionReconnectTimer.current = setInterval(async () => {
					try {
						await sessionStorage.dbAdapter.init();
						setSessionEndpointError(undefined);
						clearTimeout(sessionReconnectTimer.current);
						sessionReconnectTimer.current = undefined;
					} catch (e) {
						reportError(e);
					}
				}, 1000);
			}
			setSessionEndpointError("Mikupad server is unreachable!");
			setCurrentPromptChunk(undefined);
			setUndoHovered(false);
		}

		sessionStorage.addEventListener('sessionchange', onSessionChange);
		sessionStorage.addEventListener('error', onSessionError);
		return () => {
			sessionStorage.removeEventListener('sessionchange', onSessionChange);
			sessionStorage.removeEventListener('error', onSessionError);
		};
	}, []);

	const probs = useMemo(() =>
		showProbs && promptChunks[currentPromptChunk?.index]?.completion_probabilities?.[0]?.probs,
		[promptChunks, currentPromptChunk, showProbs]);

	return html`
		<div id="prompt-container" onMouseMove=${onPromptMouseMove}>
			<button
				className="textAreaSettings"
				onClick=${() => toggleModal("prompt")}>

				<svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="-1 -5 8 7" xmlns="http://www.w3.org/2000/svg"><path d="M0 0 3-3C3-4 3-5 5-5L4-4 5-3 6-4C6-2 5-2 4-2L1 1C0 2-1 1 0 0"></path></svg>
			</button>
			<textarea
				ref=${promptArea}
				readOnly=${!!cancel}
				spellCheck=${spellCheck}
				id="prompt-area"
				onInput=${onInput}
				onScroll=${onScroll}/>
			<div ref=${promptOverlay} id="prompt-overlay" aria-hidden>
				${highlightGenTokens || showProbsMode !== -1 ? html`
					${promptChunks.map((chunk, i) => {
						const isCurrent = currentPromptChunk && currentPromptChunk.index === i;
						const isNextUndo = undoHovered && !!undoStack.current.length && undoStack.current.at(-1) <= i;
						return html`
							<span
								key=${i}
								data-promptchunk=${i}
								className=${`${(!highlightGenTokens && !isCurrent) || chunk.type === 'user' ? 'user' : 'machine'} ${isCurrent ? 'current' : ''} ${isNextUndo ? 'erase' : ''}`}>
								${(chunk.content === '\n' ? ' \n' : chunk.content) + (i === promptChunks.length - 1 && chunk.content.endsWith('\n') ? '\u00a0' : '')}
							</span>`;
					})}` : null}
			</div>
		</div>
		${probs ? html`
			<div
				id="probs"
				style=${{
					'display': 'none'
				}}>
				${probs.map((prob, i) =>
					html`<button key=${i} onClick=${() => switchCompletion(currentPromptChunk?.index, prob.tok_str)}>
						<div className="tok">${replaceUnprintableBytes(prob.tok_str)}</div>
						<div className="prob">${(prob.prob * 100).toFixed(2)}%</div>
					</button>`)}
			</div>` : null}
		<div id="sidebar">
			<${SelectBox}
				label="Theme"
				value=${theme}
				onValueChange=${setTheme}
				options=${[
					{ name: 'Serif Light', value: 0 },
					{ name: 'Serif Dark', value: 1 },
					{ name: 'Monospace Dark', value: 2 },
					{ name: 'nockoffAI', value: 3 },
				]}/>
			<div class="horz-separator"/>
			<${CollapsibleGroup} label="Sessions">
				<${Sessions} sessionStorage=${sessionStorage} disabled=${!!cancel}/>
			</${CollapsibleGroup}>
			<${CollapsibleGroup} label="Parameters" expanded>
				<${InputBox} label="Server"
					className="${isMixedContent() ? 'mixed-content' : ''}"
					tooltip="${isMixedContent() ? 'This URL might be blocked due to mixed content. If the prediction fails, download mikupad.html and run it locally.' : ''}"
					readOnly=${!!cancel}
					value=${endpoint}
					onValueChange=${setEndpoint}/>
				<${SelectBox}
					label="API"
					disabled=${!!cancel}
					value=${endpointAPI}
					onValueChange=${switchEndpointAPI}
					options=${[
						{ name: 'llama.cpp', value: 0 },
						/*{ name: 'legacy oobabooga', value: 1 },*/
						{ name: 'koboldcpp', value: 2 },
						{ name: 'openai-compatible', value: 3 },
					]}/>
				${(endpointAPI == 3 || endpointAPI == 0) && html`
					<div className="hbox-flex" style=${{"flex-wrap": "unset"}}>
						<${InputBox} label="API Key" type="${!showAPIKey ? "password" : "text"}"
							className="${rejectedAPIKey ? 'rejected' : ''}"
							tooltip="${rejectedAPIKey ? 'This API Key was rejected by the backend.' : ''}"
							tooltipSize="short"
							readOnly=${!!cancel}
							value=${endpointAPIKey}
							onValueChange=${setEndpointAPIKey}/>
						<button title="${!showAPIKey ? "Show API Key" : "Hide API Key"}"
							className="eye-button"
							disabled=${!!cancel}
							onClick=${() => setShowAPIKey(!showAPIKey)}>
							${!showAPIKey ? html`<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24"><path d="M15 12c0 1.654-1.346 3-3 3s-3-1.346-3-3 1.346-3 3-3 3 1.346 3 3zm9-.449s-4.252 8.449-11.985 8.449c-7.18 0-12.015-8.449-12.015-8.449s4.446-7.551 12.015-7.551c7.694 0 11.985 7.551 11.985 7.551zm-7 .449c0-2.757-2.243-5-5-5s-5 2.243-5 5 2.243 5 5 5 5-2.243 5-5z" fill="var(--color-light)"/></svg>`
										  : html`<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24"><path d="M11.885 14.988l3.104-3.098.011.11c0 1.654-1.346 3-3 3l-.115-.012zm8.048-8.032l-3.274 3.268c.212.554.341 1.149.341 1.776 0 2.757-2.243 5-5 5-.631 0-1.229-.13-1.785-.344l-2.377 2.372c1.276.588 2.671.972 4.177.972 7.733 0 11.985-8.449 11.985-8.449s-1.415-2.478-4.067-4.595zm1.431-3.536l-18.619 18.58-1.382-1.422 3.455-3.447c-3.022-2.45-4.818-5.58-4.818-5.58s4.446-7.551 12.015-7.551c1.825 0 3.456.426 4.886 1.075l3.081-3.075 1.382 1.42zm-13.751 10.922l1.519-1.515c-.077-.264-.132-.538-.132-.827 0-1.654 1.346-3 3-3 .291 0 .567.055.833.134l1.518-1.515c-.704-.382-1.496-.619-2.351-.619-2.757 0-5 2.243-5 5 0 .852.235 1.641.613 2.342z" fill="var(--color-light)"/></svg>`}
						</button>
					</div>`}
				${endpointAPI == 3 && html`
					<${InputBox} label="Model"
						datalist=${openaiModels}
						readOnly=${!!cancel}
						value=${endpointModel}
						onValueChange=${setEndpointModel}/>`}
				<div className="buttons instructTemplateSidebar">
					<${SelectBoxTemplate}
						label="Instruct Template"
						disabled=${!!cancel}
						value=${selectedTemplate}
						onValueChange=${setSelectedTemplate}
						options=${templateList}/>
					<button
						title="Edit Instruct Templates"
						disabled=${!!cancel}
						class="symbol-button"
						onClick=${() => toggleModal("instruct")}>
						<svg style=${{ 'width':'.95em','transform':'translate(-50%, -45%)' }} xmlns="http://www.w3.org/2000/svg"  viewBox="-1 -5 8 7"><path d="M0 0 3-3C3-4 3-5 5-5L4-4 5-3 6-4C6-2 5-2 4-2L1 1C0 2-1 1 0 0" fill="var(--color-light)"/></svg>
					</button>
					<button
						title="Insert System Prompt Template"
						disabled=${!!cancel}
						class="symbol-button"
						onClick=${() => insertTemplate("sys")}>
						<svg style=${{ 'width':'.9em' }} xmlns="http://www.w3.org/2000/svg"  viewBox="0 -10 10 10"><path d="M 0 -2 L 1 -1 L 5 -5 L 1 -9 L 0 -8 L 3 -5 L 0 -2 M 4 -1 L 10 -1 L 10 -2.4 L 4 -2.4" fill="var(--color-light)"/></svg>
					</button>
					<button
						title="Insert Instruct Template"
						disabled=${!!cancel}
						class="symbol-button"
						onClick=${() => insertTemplate("inst")}>
						<svg style=${{ 'height':'1.05em','transform':'translate(-50%, -60%)' }} xmlns="http://www.w3.org/2000/svg"  viewBox="0 -10 5 10"><path d="M 2.5 -6 A 0.75 0.75 90 0 0 3.25 -6.75 A 0.75 0.75 90 0 0 2.5 -7.5 A 0.75 0.75 90 0 0 1.75 -6.75 A 0.75 0.75 90 0 0 2.5 -6 M 1 0 L 4 0 L 4 -1 L 3 -1 L 3 -5 L 1 -5 L 1 -4 L 2 -4 L 2 -1 L 1 -1 Z" fill="var(--color-light)"/></svg>
					</button>
					<button
						title="Toggle Chat Mode ${ chatMode ? "Off" : "On"}"
						disabled=${!!cancel}
						class="symbol-button"
						onClick=${() => setChatMode( (prevState) => !prevState)}>
						${ chatMode ? 
						  html`<svg style=${{ 'width':'.9em' }} xmlns="http://www.w3.org/2000/svg"  viewBox="0 0 10 10"><path d="M 2 10 L 2 7 Q 0 7 0 5 L 0 2 Q 0 0 2 0 L 8 0 Q 10 0 10 2 Q 10 2 10 3 L 10 5 Q 10 7 8 7 L 6 7 Z" fill="var(--color-light)"/></svg>`
						: html`<svg style=${{ 'width':'.9em' }} xmlns="http://www.w3.org/2000/svg"  viewBox="0 0 31 31"><path d="M 0 32 L 3 23 L 26 0 L 32 6 L 9 29 Z M 22 4 L 28 10 L 29 9 L 23 3 M 3 23 L 9 29 L 10 28 L 4 22 Z" fill="var(--color-light)"/></svg>`
						}
					</button>
				</div>
				<${InputBox} label="Seed (-1 = random)" type="text" inputmode="numeric"
					readOnly=${!!cancel} value=${seed} onValueChange=${setSeed}/>
				<${InputBox} tooltip="Currently not accurate to the token count, it will be used as an estimate." label="Max Context Length" type="text" inputmode="numeric"
					readOnly=${!!cancel} value=${contextLength} onValueChange=${setContextLength}/>
				<${InputBox} label="Max Predict Tokens${endpointAPI != 0 ? ' (-1 = 1024)' : ' (-1 = infinite)'}" type="text" inputmode="numeric"
					readOnly=${!!cancel} value=${maxPredictTokens} onValueChange=${setMaxPredictTokens}/>
				<${InputBox} label="Stopping Strings (JSON array)" type="text" pattern="^\\[.*?\\]$"
					className="${stoppingStringsError ? 'rejected' : ''}"
					tooltip="${stoppingStringsError ? stoppingStringsError : ''}"
					readOnly=${!!cancel}
					value=${stoppingStrings}
					onValueChange=${setStoppingStrings}/>
			</${CollapsibleGroup}>
			<${CollapsibleGroup} label="Sampling" expanded>
				${endpointAPI == 3 && html`
					<${Checkbox} label="Full OpenAI compliance"
						disabled=${!!cancel} value=${openaiPresets} onValueChange=${setOpenaiPresets}/>`}
				<${InputBox} label="Temperature" type="number" step="0.01"
					readOnly=${!!cancel} value=${temperature} onValueChange=${setTemperature}/>
				${(!openaiPresets || endpointAPI != 3) && html`
					<div className="hbox">
						<${InputBox} label="DynaTemp Range" type="number" step="0.01"
							readOnly=${!!cancel} value=${dynaTempRange} onValueChange=${setDynaTempRange}/>
						${(endpointAPI != 2) && html`
							<${InputBox} label="DynaTemp Exp" type="number" step="0.01"
								readOnly=${!!cancel} value=${dynaTempExp} onValueChange=${setDynaTempExp}/>`}
					</div>
					<div className="hbox">
						<${InputBox} label="Repeat penalty" type="number" step="0.01"
							readOnly=${!!cancel} value=${repeatPenalty} onValueChange=${setRepeatPenalty}/>
						<${InputBox} label="Repeat last n" type="number" step="1"
							readOnly=${!!cancel} value=${repeatLastN} onValueChange=${setRepeatLastN}/>
					</div>`}
				${(endpointAPI == 0 || !openaiPresets || endpointAPI == 3) && html`
					${(endpointAPI != 1 && (!openaiPresets || endpointAPI != 3)) && html`
						<${Checkbox} label="Penalize NL"
							disabled=${!!cancel} value=${penalizeNl} onValueChange=${setPenalizeNl}/>`}
					<div className="hbox">
						<${InputBox} label="Presence penalty" type="number" step="0.01"
							readOnly=${!!cancel} value=${presencePenalty} onValueChange=${setPresencePenalty}/>
						<${InputBox} label="Frequency penalty" type="number" step="1"
							readOnly=${!!cancel} value=${frequencyPenalty} onValueChange=${setFrequencyPenalty}/>
					</div>`}
				${temperature <= 0 ? null : html`
					${(!openaiPresets || endpointAPI != 3) && html`
						<${SelectBox}
							label="Mirostat"
							disabled=${!!cancel}
							value=${mirostat}
							onValueChange=${setMirostat}
							options=${[
								{ name: 'Off', value: 0 },
								{ name: 'Mirostat', value: 1 },
								{ name: 'Mirostat 2.0', value: 2 },
							]}/>`}
					${(mirostat && (!openaiPresets || endpointAPI != 3)) ? html`
						<div className="hbox">
							<${InputBox} label="Mirostat τ" type="number" step="0.01"
								readOnly=${!!cancel} value=${mirostatTau} onValueChange=${setMirostatTau}/>
							<${InputBox} label="Mirostat η" type="number" step="0.01"
								readOnly=${!!cancel} value=${mirostatEta} onValueChange=${setMirostatEta}/>
						</div>
					` : html`
						<div className="hbox">
							${(!openaiPresets || endpointAPI != 3) && html`
								<${InputBox} label="Top K" type="number" step="1"
									readOnly=${!!cancel} value=${topK} onValueChange=${setTopK}/>`}
							<${InputBox} label="Top P" type="number" step="0.01"
								readOnly=${!!cancel} value=${topP} onValueChange=${setTopP}/>
							${(!openaiPresets || endpointAPI != 3) && html`
								<${InputBox} label="Min P" type="number" step="0.01"
									readOnly=${!!cancel} value=${minP} onValueChange=${setMinP}/>`}
						</div>
						${(!openaiPresets || endpointAPI != 3) && html`
							<div className="hbox">
								<${InputBox} label="Typical p" type="number" step="0.01"
									readOnly=${!!cancel} value=${typicalP} onValueChange=${setTypicalP}/>
								<${InputBox} label="TFS z" type="number" step="0.01"
									readOnly=${!!cancel} value=${tfsZ} onValueChange=${setTfsZ}/>
							</div>`}
					`}
				`}
				${(endpointAPI != 3) && html`
					<button
						disabled=${!!cancel}
						onClick=${() => toggleModal("bias")}>
						Logit Bias
						</button>`}
				${(!openaiPresets || endpointAPI != 3) && html`
					<${Checkbox} label="Ignore <eos>"
						disabled=${!!cancel} value=${ignoreEos} onValueChange=${setIgnoreEos}/>`}


			</${CollapsibleGroup}>
			<${CollapsibleGroup} label="Persistent Context">
				<label className="TextArea">
					<div>Memory ${memoryTokens.tokens > 0 ? html`<small>(${memoryTokens.tokens} Tokens)</small>`:""}</div>
					<textarea
					readOnly=${!!cancel}
					placeholder="Anything written here will be injected at the head of the prompt. Tokens here DO count towards the Context Limit."
					defaultValue=${memoryTokens.text}
					value=${memoryTokens.text}
					onInput=${(e) => handleMemoryTokensChange("text", e.target.value) }
					id="memory-area"/>
					<button
					className="textAreaSettings"
					disabled=${!!cancel}
					onClick=${() => toggleModal("memory")}>
					<svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="-1 -5 8 7" xmlns="http://www.w3.org/2000/svg"><path d="M0 0 3-3C3-4 3-5 5-5L4-4 5-3 6-4C6-2 5-2 4-2L1 1C0 2-1 1 0 0"></path></svg>
					</button>
				</label>
				<label className="TextArea">
					<div>Author's Note ${authorNoteTokens.tokens > 0 ? html`<small>(${authorNoteTokens.tokens} Tokens)</small>`:""}</div>
					<textarea
					readOnly=${!!cancel}
					placeholder="Anything written here will be injected ${authorNoteDepth} newlines from bottom into context."
					defaultValue=${authorNoteTokens.text}
					value=${authorNoteTokens.text}
					onInput=${(e) => handleauthorNoteTokensChange("text", e.target.value) }
					id="an-area"/>
					<button
					className="textAreaSettings"
					disabled=${!!cancel}
					onClick=${() => toggleModal("an")}>
					<svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="-1 -5 8 7" xmlns="http://www.w3.org/2000/svg"><path d="M0 0 3-3C3-4 3-5 5-5L4-4 5-3 6-4C6-2 5-2 4-2L1 1C0 2-1 1 0 0"></path></svg>
					</button>
				</label>
				<button
					id="viewWorldInfo"
					disabled=${!!cancel}
					onClick=${() => toggleModal("wi")}>
					Show World Info
				</button>
				<button
					id="viewContext"
					disabled=${!!cancel}
					onClick=${() => toggleModal("context")}>
					Show Context
				</button>

			</${CollapsibleGroup}>
			${!!tokens && html`
				<${InputBox} label="Tokens" value=${tokens} readOnly/>`}
			<div className="buttons">
				<button
					title="Run next prediction (Ctrl + Enter)"
					className=${cancel && !sessionEndpointConnecting ? (predictStartTokens === tokens ? 'processing' : 'completing') : ''}
					disabled=${!!cancel || stoppingStringsError}
					onClick=${() => predict()}>
					Predict
				</button>
				<button
					title="Cancel prediction (Escape)"
					disabled=${!cancel || sessionEndpointConnecting}
					onClick=${cancel}>
					Cancel
				</button>
				<div className="shorts">
					<button
						title="Regenerate (Ctrl + R)"
						disabled=${!undoStack.current.length}
						onClick=${() => undoAndPredict()}
						onMouseEnter=${() => setUndoHovered(true)}
						onMouseLeave=${() => setUndoHovered(false)}>
						<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 40.499 40.5"><path d="M39.622,21.746l-6.749,6.75c-0.562,0.562-1.326,0.879-2.122,0.879s-1.56-0.316-2.121-0.879l-6.75-6.75		c-1.171-1.171-1.171-3.071,0-4.242c1.171-1.172,3.071-1.172,4.242,0l1.832,1.832C27.486,13.697,22.758,9.25,17,9.25		c-6.064,0-11,4.935-11,11c0,6.064,4.936,11,11,11c1.657,0,3,1.343,3,3s-1.343,3-3,3c-9.373,0-17-7.626-17-17s7.627-17,17-17		c8.936,0,16.266,6.933,16.936,15.698l1.442-1.444c1.172-1.172,3.072-1.172,4.242,0C40.792,18.674,40.792,20.574,39.622,21.746z" fill="var(--color-light)"/></svg>
					</button>
				</div>

				<div className="shorts">
					<button
						title="Undo (Ctrl + Z)"
						disabled=${!!cancel || !undoStack.current.length}
						onClick=${() => undo()}
						onMouseEnter=${() => setUndoHovered(true)}
						onMouseLeave=${() => setUndoHovered(false)}>
						<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24"><path d="M17.026 22.957c10.957-11.421-2.326-20.865-10.384-13.309l2.464 2.352h-9.106v-8.947l2.232 2.229c14.794-13.203 31.51 7.051 14.794 17.675z" fill="var(--color-light)"/></svg>
					</button>
					<button
						title="Redo (Ctrl + Y)"
						disabled=${!!cancel || !redoStack.current.length}
						onClick=${() => redo()}>
						<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24"><path d="M6.974 22.957c-10.957-11.421 2.326-20.865 10.384-13.309l-2.464 2.352h9.106v-8.947l-2.232 2.229c-14.794-13.203-31.51 7.051-14.794 17.675z" fill="var(--color-light)"/></svg>
					</button>
				</div>
			</div>
			${!!lastError && html`
				<span className="error-text">${lastError}</span>`}
		</div>

		<${EditorPreferencesModal}
			isOpen=${modalState.prompt}
			closeModal=${() => closeModal("prompt")}>
			<${Checkbox} label="Enable spell checking"
				value=${spellCheck} onValueChange=${setSpellCheck}/>
			<${Checkbox} label="Attach sidebar"
				value=${attachSidebar} onValueChange=${setAttachSidebar}/>
			<${Checkbox} label="Highlight generated tokens"
				value=${highlightGenTokens} onValueChange=${setHighlightGenTokens}/>
			<${Checkbox} label="Preserve cursor position after prediction (disabled in Chat Mode)"
				value=${preserveCursorPosition} onValueChange=${setPreserveCursorPosition}/>
			<${SelectBox}
				label="Token probabilities"
				value=${showProbsMode}
				onValueChange=${setShowProbsMode}
				options=${[
					{ name: 'Show on hover', value: 0 },
					{ name: 'Show on hover while holding CTRL', value: 1 },
					{ name: 'Don\'t show', value: -1 },
				]}/>
			<div style=${{ display: 'flex', justifyContent: 'flex-start' }}>
				<button onClick=${() => exportText(`${sessionStorage.getProperty('name')}.txt`, promptArea.current.value)}>
					Export prompt to plaintext
				</button>
			</div>
		</${EditorPreferencesModal}>

		<${MemoryModal}
			isOpen=${modalState.memory}
			closeModal=${() => closeModal("memory")}
			memoryTokens=${memoryTokens}
			handleMemoryTokensChange=${handleMemoryTokensChange}
			cancel=${cancel}/>

		<${AuthorNoteModal}
			isOpen=${modalState.an}
			closeModal=${() => closeModal("an")}
			authorNoteTokens=${authorNoteTokens}
			handleauthorNoteTokensChange=${handleauthorNoteTokensChange}
			authorNoteDepth=${authorNoteDepth}
			setAuthorNoteDepth=${setAuthorNoteDepth}
			cancel=${cancel}/>

		<${ContextModal}
			isOpen=${modalState.context}
			closeModal=${() => closeModal("context")}
			tokens=${tokens}
			memoryTokens=${memoryTokens}
			authorNoteTokens=${authorNoteTokens}
			handleMemoryTokensChange=${handleMemoryTokensChange}
			modifiedPrompt=${modifiedPrompt}
			defaultPresets=${defaultPresets}
			cancel=${cancel}/>

		<${WorldInfoModal}
			isOpen=${modalState.wi}
			closeModal=${() => closeModal("wi")}
			worldInfo=${worldInfo}
			setWorldInfo=${setWorldInfo}
			cancel=${cancel}/>

		<!-- TODO: The amount of parameters in this modal is a bit excessive... -->
		<${LogitBiasModal}
			isOpen=${modalState.bias}
			closeModal=${() => closeModal("bias")}
			logitBias=${logitBias}
			setLogitBias=${setLogitBias}
			logitBiasParam=${logitBiasParam}
			setLogitBiasParam=${setLogitBiasParam}
			sessionStorage=${sessionStorage} endpoint=${endpoint} endpointAPI=${endpointAPI} endpointAPIKey=${endpointAPIKey} isMikupadEndpoint=${isMikupadEndpoint}
			cancel=${cancel}/>

		<!-- Sorry. -->
		<${InstructModal}
			isOpen=${modalState.instruct}
			closeModal=${() => closeModal("instruct")}
			templateList=${templateList}
			setTemplateList=${setTemplateList}
			selectedTemplate=${selectedTemplate}
			setSelectedTemplate=${setSelectedTemplate}
			templatesImport=${templatesImport}
			templates=${templates}
			setTemplates=${setTemplates}
			templateStorage=${templateStorage}
			cancel=${cancel}/>

		${sessionEndpointError && html`
			<div className="modal-overlay">
				<div id="error-bar">
					<div>
						${sessionEndpointError}
					</div>
				</div>
			</div>`}
	`;
}

async function main() {
	let dbAdapter = new IndexedDBAdapter();
	let isMikupadEndpoint = false;

	if (window.location.protocol != 'file:' && window.location.pathname == '/') {
		let serverAdapter = new ServerDBAdapter(window.location.protocol + '//' + window.location.host);
		try {
			await serverAdapter.init();
			dbAdapter = serverAdapter;
			isMikupadEndpoint = true;
		} catch (e) {
			reportError(e);
		}
	}

	const sessionStorage = new SessionStorage(dbAdapter);
	await sessionStorage.init();

	const templateStorage = new TemplateStorage(dbAdapter);
	await templateStorage.init();

	createRoot(document.body).render(html`
		<${App}
			sessionStorage=${sessionStorage}
			templateStorage=${templateStorage}
			useSessionState=${(name, initialState) => useSessionState(sessionStorage, name, initialState)}
			useDBTemplates=${(initialState => useDBTemplates(templateStorage, initialState))}
			isMikupadEndpoint=${isMikupadEndpoint}/>`);
}

main();
</script>
