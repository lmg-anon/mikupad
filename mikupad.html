<!doctype html>
<meta charset="utf-8">
<!-- mikupad by Anon
  --
  -- To the extent possible under law, the person who associated CC0 with
  -- mikupad has waived all copyright and related or neighboring rights
  -- to mikupad.
  --
  -- You should have received a copy of the CC0 legalcode along with this
  -- work.  If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.
  -->
<title>mikupad</title>
<script type="importmap">
{
	"imports": {
		"react": "https://esm.sh/react@18",
		"react-dom/client": "https://esm.sh/react-dom@18/client?external=react",
		"htm/react": "https://esm.sh/htm@3/react?external=react&react=18",
		"event-iterator": "https://esm.sh/event-iterator@2.0.0"
	}
}
</script>
<style>

html {
	--color-miku: #009bb3;
	--color-base-0: oklch(0.20 0.02 60);
	--color-base-10: color-mix(in oklch, var(--color-base-100) 10%, var(--color-base-0));
	--color-base-20: color-mix(in oklch, var(--color-base-100) 20%, var(--color-base-0));
	--color-base-30: color-mix(in oklch, var(--color-base-100) 30%, var(--color-base-0));
	--color-base-40: color-mix(in oklch, var(--color-base-100) 40%, var(--color-base-0));
	--color-base-50: color-mix(in oklch, var(--color-base-100) 50%, var(--color-base-0));
	--color-base-60: color-mix(in oklch, var(--color-base-100) 60%, var(--color-base-0));
	--color-base-70: color-mix(in oklch, var(--color-base-100) 70%, var(--color-base-0));
	--color-base-80: color-mix(in oklch, var(--color-base-100) 80%, var(--color-base-0));
	--color-base-90: color-mix(in oklch, var(--color-base-100) 90%, var(--color-base-0));
	--color-base-100: oklch(0.95 0.04 70);
	--color-dark: var(--color-base-0);
	--color-light: var(--color-base-100);

	font: 16px 'Open Serif', serif;
	min-height: 100%;
	display: flex;
	flex-direction: column;

	accent-color: var(--color-base-30);
	background: var(--color-base-20);
	color: var(--color-base-0);
}

html.dark-mode {
	--color-base-0: oklch(0.95 0.04 30);
	--color-base-10: color-mix(in oklch, var(--color-base-100) 10%, var(--color-base-0));
	--color-base-20: color-mix(in oklch, var(--color-base-100) 80%, var(--color-base-0));
	--color-base-30: color-mix(in oklch, var(--color-base-100) 70%, var(--color-base-0));
	--color-base-40: color-mix(in oklch, var(--color-base-100) 60%, var(--color-base-0));
	--color-base-50: color-mix(in oklch, var(--color-base-100) 50%, var(--color-base-0));
	--color-base-60: color-mix(in oklch, var(--color-base-100) 40%, var(--color-base-0));
	--color-base-70: color-mix(in oklch, var(--color-base-100) 30%, var(--color-base-0));
	--color-base-80: color-mix(in oklch, var(--color-base-100) 20%, var(--color-base-0));
	--color-base-90: color-mix(in oklch, var(--color-base-100) 10%, var(--color-base-0));
	--color-base-100: oklch(0.20 0.02 30);
	--color-dark: var(--color-base-100);
	--color-light: var(--color-base-0);
}

body {
	margin: 0;
	display: flex;
	flex: auto;
	flex-direction: row;
}

#prompt-container {
	position: relative;
	font-size: 1.125rem;
	max-width: 36em;
	margin-right: auto;
	margin-left: auto;
	flex: 1;
	display: flex;
	flex-direction: column;
}

#prompt-area, #prompt-overlay {
	flex: 1;
	border: none;
	outline: none;
	resize: none;
	background: var(--color-base-100);
	color: var(--color-base-10);
	padding: 2em 3em;
	margin: 0;
	scrollbar-gutter: stable;
	font: inherit;
}

#prompt-overlay {
	white-space: pre-wrap;
	position: absolute;
	left: 0;
	top: 0;
	right: 0;
	bottom: 0;
	background: transparent;
	color: transparent;
	pointer-events: none;
	overflow: auto;
}

#prompt-container:hover #prompt-overlay > .machine {
	background: color-mix(in srgb, var(--color-miku) 10%, transparent);
}
#prompt-container #prompt-overlay > .machine.current {
	border-radius: 3px;
	outline: 1px solid var(--color-base-50);
	outline-offset: 1px;
}

#probs {
	position: absolute;
	background: var(--color-base-30);
	top: var(--probs-top);
	left: var(--probs-left);
	display: flex;
	translate: -50% -100%;
	border-radius: 5px;
	box-shadow: 0 1px 1px 1px #00000033;
	transition: top 0.2s, left 0.2s;
}
#probs > button {
	background: transparent;
	color: var(--color-light);
	border-radius: 0;
	padding: 2px 3px;
	display: flex;
	flex-direction: column;
	flex: none;
	font-size: 0.875rem;
}
#probs > button:first-child {
	border-radius: 5px 0 0 5px;
	padding-left: 6px;
}
#probs > button:last-child {
	border-radius: 0 5px 5px 0;
	padding-right: 6px;
}
#probs > button:hover {
	background: var(--color-base-40);
}
#probs > button:active {
	background: var(--color-base-50);
}
#probs > button > .prob {
	font-size: 0.75rem;
}

#sidebar {
	width: 250px;
	background: var(--color-base-50);
	color: var(--color-light);
	padding: 4px 8px;
	display: flex;
	flex-direction: column;
	gap: 4px;
	overflow: auto;
}

.sidebar-hbox {
	flex: none;
	display: grid;
	grid: auto / auto-flow minmax(min-content, 1fr);
	gap: 8px;
}

.InputBox, .SelectBox {
	display: flex;
	flex-direction: column;
	font-size: 0.75rem;
	padding: 0 8px;
}
.InputBox > input, .SelectBox > select {
	appearance: none;
	border: none;
	outline: none;
	width: 100%;
	box-sizing: content-box;
	font: inherit;
	font-size: 1rem;
	padding: 4px 8px;
	margin: 0 -8px;
	border-radius: 2px;
	color: inherit;
	background: var(--color-base-30);
	flex: none;
}
.InputBox > input:read-only {
	background: var(--color-base-60);
}
.InputBox > input:focus-visible {
	outline: 1px solid var(--color-base-0);
}

.Checkbox {
	margin: 0 5px 0 0;
	vertical-align: middle;
}

button {
	appearance: none;
	border: none;
	outline: none;
	font: inherit;
	padding: 4px 8px;
	color: inherit;
	background: var(--color-base-30);
	border-radius: 2px;
}
button:hover {
	background: var(--color-base-40);
}
button:active {
	background: var(--color-base-50);
}
button:disabled {
	background: var(--color-base-60);
}
button:focus-visible {
	outline: 1px solid var(--color-base-0);
}
button.completing {
	outline: 1px solid limegreen;
	animation: .5s ease-out infinite alternate completing;
}
@keyframes completing {
	from { outline-width: 0px; }
	to { outline-width: 4px; }
}

.buttons {
	display: flex;
	gap: 8px;
	justify-content: center;
}

</style>
<script type="module">

import { useEffect, useLayoutEffect, useMemo, useRef, useState } from 'react';
import { createRoot } from 'react-dom/client';
import { html } from 'htm/react';
import { EventIterator } from "event-iterator"

// Polyfill for piece of shit Chromium
if (!(Symbol.asyncIterator in ReadableStream.prototype)) {
	ReadableStream.prototype[Symbol.asyncIterator] = async function* () {
		const reader = this.getReader();
		try {
			for (;;) {
				const { done, value } = await reader.read();
				if (done)
					return;
				yield value;
			}
		} finally {
			reader.releaseLock();
		}
	};
}

export async function tokenize({ endpoint, endpointAPI, signal, ...options }) {
	switch (endpointAPI) {
		case 0: // llama.cpp
			return await llamaCppTokenize({ endpoint, signal, ...options });
		case 1: // oobabooga
			return await new Promise((resolve) => resolve({ tokens: [] })); // i don't know if ooba support this.
		case 2: // koboldcpp
			return await new Promise((resolve) => resolve({ tokens: [] })); // koboldcpp doesn't support this.
	}
}

export async function* completion({ endpoint, endpointAPI, signal, ...options }) {
	if (options['seed'] === -1)
		delete options['seed'];
	switch (endpointAPI) {
		case 0: // llama.cpp
			return yield* await llamaCppCompletion({ endpoint, signal, ...options });
		case 1: // oobabooga
			return yield* await oobaCompletion({ endpoint, signal, ...options });
		case 2: // koboldcpp
			return yield* await koboldCppCompletion({ endpoint, signal, ...options });
	}
}

export async function abortCompletion({ endpoint, endpointAPI }) {
	switch (endpointAPI) {
		case 1: // oobabooga
			try {
				endpoint = `${endpoint.replace("ws:", "http:").split(":")[0]}:5000`; // HACK!
				return await oobaAbortCompletion({ endpoint });
			} catch {
				break; // do nothing.
			}
		case 2: // koboldcpp
			return await koboldCppAbortCompletion({ endpoint });
	}
}

// Function to parse text/event-stream data and yield JSON objects
async function* parseEventStream(eventStream) {
	let buf = '';
	let ignoreNextLf = false;

	for await (let chunk of eventStream.pipeThrough(new TextDecoderStream())) {
		// A CRLF could be split between chunks, so if the last chunk ended in
		// CR and this chunk started with LF, trim the LF
		if (ignoreNextLf && /^\n/.test(chunk)) {
			chunk = chunk.slice(1);
		}
		ignoreNextLf = /\r$/.test(chunk);

		// Event streams must be parsed line-by-line (ending in CR, LF, or CRLF)
		const lines = (buf + chunk).split(/\n|\r\n?/);
		buf = lines.pop();
		let type, data;

		for (const line of lines) {
			if (!line) {
				// We only emit message-type events for now (and assume JSON)
				if (data && (type || 'message') === 'message') {
					const json = JSON.parse(data);
					// Both Chrome and Firefox suck at debugging
					// text/event-stream, so make it easier by logging events
					console.log('event', json);
					yield json;
				}
				type = undefined;
				data = undefined;
				continue;
			}
			const { name, value } = /^(?<name>.*?)(?:: ?(?<value>.*))?$/s.exec(line).groups;
			switch (name) {
				case 'event':
					type = (value ?? '');
					break;
				case 'data':
					data = data === undefined ? (value ?? '') : `${data}\n${value}`;
					break;
			}
		}
	}
}

async function llamaCppTokenize({ endpoint, signal, ...options }) {
	const res = await fetch(new URL('/tokenize', endpoint), {
		method: 'POST',
		headers: {
			'Content-Type': 'application/json',
		},
		body: JSON.stringify(options),
		signal,
	});
	if (!res.ok)
		throw new Error(`HTTP ${res.status}`);
	return await res.json();
}

async function* llamaCppCompletion({ endpoint, signal, ...options }) {
	const res = await fetch(new URL('/completion', endpoint), {
		method: 'POST',
		headers: {
			'Content-Type': 'application/json',
		},
		body: JSON.stringify({
			...options,
			stream: true,
		}),
		signal,
	});
	if (!res.ok)
		throw new Error(`HTTP ${res.status}`);
	return yield* await parseEventStream(res.body);
}

function oobaConvertOptions(options) {
	const swapOption = (lhs, rhs) => {
		if (lhs in options) {
			options[rhs] = options[lhs];
			delete options[lhs];
		}
	};
	swapOption("n_ctx", "truncation_length");
	swapOption("n_predict", "max_new_tokens");
	swapOption("repeat_penalty", "repetition_penalty");
	swapOption("repeat_last_n", "repetition_penalty_range");
	swapOption("stop", "stopping_strings");
	return options;
}

async function* oobaCompletion({ endpoint, signal, ...options }) {
	const ws = new WebSocket(new URL('/api/v1/stream', endpoint));

	ws.onopen = () => {
		ws.send(JSON.stringify(oobaConvertOptions(options)));
	};

	const wsStream = () => new EventIterator(
		queue => {
			ws.onmessage = queue.push;
			ws.onclose = queue.stop;
			ws.onerror = queue.fail;
			if (signal) {
				signal.addEventListener("abort", queue.stop);
			}

			return () => {
				ws.close();
				if (signal) {
					signal.removeEventListener("abort", queue.stop);
				}
			}
		}
	);

	for await (const event of wsStream()) {
		const data = JSON.parse(event.data);
		console.log('event', data);

		if (data.event === "text_stream") {
			yield { content: data.text };
		} else if (data.event === "stream_end") {
			break;
		}
	}
}

async function oobaAbortCompletion({ endpoint }) {
	await fetch(new URL('/api/v1/stop-stream', endpoint), {
		method: 'POST',
	});
}

function koboldCppConvertOptions(options) {
	const swapOption = (lhs, rhs) => {
		if (lhs in options) {
			options[rhs] = options[lhs];
			delete options[lhs];
		}
	};
	swapOption("n_ctx", "max_context_length");
	swapOption("n_predict", "max_tokens");
	swapOption("repeat_penalty", "rep_pen");
	swapOption("repeat_last_n", "rep_pen_range");
	swapOption("tfs_z", "tfs");
	swapOption("typical_p", "typical");
	swapOption("seed", "sampler_seed");
	swapOption("stop", "stop_sequence");
	return options;
}

async function* koboldCppCompletion({ endpoint, signal, ...options }) {
	const res = await fetch(new URL('/api/extra/generate/stream', endpoint), {
		method: 'POST',
		headers: {
			'Content-Type': 'application/json',
		},
		body: JSON.stringify({
			...koboldCppConvertOptions(options),
			stream: true,
		}),
		signal,
	});
	if (!res.ok)
		throw new Error(`HTTP ${res.status}`);
	for await (const chunk of parseEventStream(res.body)) {
		yield { content: chunk.token };
	}
}

async function koboldCppAbortCompletion({ endpoint }) {
	await fetch(new URL('/api/extra/abort', endpoint), {
		method: 'POST',
	});
}

function InputBox({ label, value, type, onValueChange, ...props }) {
	return html`
		<label className="InputBox">
			${label}
			<input
				type=${type || 'text'}
				value=${value}
				size="1"
				onChange=${({ target }) => {
					onValueChange(type === 'number' ? target.valueAsNumber : target.value);
				}}
				...${props}/>
		</label>`;
}

function SelectBox({ label, value, onValueChange, options, ...props }) {
	return html`
		<label className="SelectBox">
			${label}
			<select
				value=${value}
				onChange=${({ target }) => onValueChange(JSON.parse(target.value))}
				...${props}>
				${options.map(o => html`<option
					key=${JSON.stringify(o.value)}
					value=${JSON.stringify(o.value)}>${o.name}</option>`)}
			</select>
		</label>`;
}

function Checkbox({ label, value, onValueChange, ...props }) {
	return html`
		<label className="Checkbox">
			<input
				type="checkbox"
				checked=${value}
				onChange=${({ target }) => onValueChange(target.checked)}
				...${props}/>
			${label}
		</label>`;
}

const defaultPrompt = `[INST] <<SYS>>
You are a talented writing assistant. Always respond by incorporating the instructions into expertly written prose that is highly detailed, evocative, vivid and engaging.
<</SYS>>

Write a story about Hatsune Miku and Kagamine Rin. [/INST]  Sure, how about this:

Chapter 1
`;

function joinPrompt(prompt) {
	return prompt.map(p => p.content).join('');
}

function usePersistentState(name, initialState) {
	let savedState;
	try {
		savedState = JSON.parse(localStorage.getItem(name));
	} catch {
		savedState = null;
	}
	const [value, setValue] = useState(savedState || initialState);
	return [value, (newValue) => {
		if (typeof newValue === 'function') {
			setValue(v => {
				newValue = newValue(v);
				localStorage.setItem(name, JSON.stringify(newValue));
				return newValue;
			});
		} else {
			localStorage.setItem(name, JSON.stringify(newValue));
			setValue(newValue);
		}
	}]
}

function resetPersistence() {
	localStorage.clear();
	location.reload();
}

export function App() {
	const promptArea = useRef();
	const promptOverlay = useRef();
	const [currentPromptChunk, setCurrentPromptChunk] = useState(undefined);
	const [cancel, setCancel] = useState(null);
	const [darkMode, setDarkMode] = usePersistentState('darkMode', false);
	const [endpoint, setEndpoint] = usePersistentState('endpoint', 'http://localhost:8080');
	const [endpointAPI, setEndpointAPI] = usePersistentState('endpointAPI', 0);
	const [prompt, setPrompt] = usePersistentState('prompt', [{ type: 'user', content: defaultPrompt }]);
	const [seed, setSeed] = usePersistentState('seed', -1);
	const [temperature, setTemperature] = usePersistentState('temperature', 0.7); // llama.cpp default 0.8
	const [repeatPenalty, setRepeatPenalty] = usePersistentState('repeatPenalty', 1.1);
	const [repeatLastN, setRepeatLastN] = usePersistentState('repeatLastN', 256); // llama.cpp default 64
	const [penalizeNl, setPenalizeNl] = usePersistentState('penalizeNl', true);
	const [presencePenalty, setPresencePenalty] = usePersistentState('presencePenalty', 0);
	const [frequencyPenalty, setFrequencyPenalty] = usePersistentState('frequencyPenalty', 0);
	const [topK, setTopK] = usePersistentState('topK', 40);
	const [topP, setTopP] = usePersistentState('topP', 0.95);
	const [typicalP, setTypicalP] = usePersistentState('typicalP', 1);
	const [tfsZ, setTfsZ] = usePersistentState('tfsZ', 1);
	const [mirostat, setMirostat] = usePersistentState('mirostat', 2); // llama.cpp default 0
	const [mirostatTau, setMirostatTau] = usePersistentState('mirostatTau', 5.0);
	const [mirostatEta, setMirostatEta] = usePersistentState('mirostatEta', 0.1);
	const [ignoreEos, setIgnoreEos] = usePersistentState('ignoreEos', false);
	const [tokens, setTokens] = useState(0);

	const promptText = useMemo(() => joinPrompt(prompt), [prompt]);

	if (darkMode) {
		switchDarkMode(darkMode, true);
	}

	async function predict(prompt = promptText) {
		const ac = new AbortController();
		const cancel = () => {
			abortCompletion({ endpoint, endpointAPI });
			ac.abort();
		};
		setCancel(() => cancel);
		try {
			const { tokens } = await tokenize({
				endpoint,
				endpointAPI,
				content: ` ${prompt}`,
				signal: ac.signal,
			});
			setTokens(tokens.length + 1);

			for await (const chunk of completion({
				endpoint,
				endpointAPI,
				prompt,
				seed,
				temperature,
				repeat_penalty: repeatPenalty,
				repeat_last_n: repeatLastN,
				penalize_nl: penalizeNl,
				presence_penalty: presencePenalty,
				frequency_penalty: frequencyPenalty,
				mirostat,
				...(mirostat ? {
					mirostat_tau: mirostatTau,
					mirostat_eta: mirostatEta,
				} : {
					top_k: topK,
					top_p: topP,
					typical_p: typicalP,
					tfs_z: tfsZ,
				}),
				ignore_eos: ignoreEos,
				n_probs: 10,
				signal: ac.signal,
			})) {
				ac.signal.throwIfAborted();
				if (!chunk.content)
					continue;
				setPrompt(p => [...p, chunk]);
				setTokens(t => t + (chunk?.completion_probabilities?.length ?? 1));
			}
		} catch (e) {
			if (e.name !== 'AbortError')
				reportError(e);
		} finally {
			setCancel(c => c === cancel ? null : c);
		}
	}

	// Update the textarea in an uncontrolled way so the user doesn't lose their
	// selection or cursor position during prediction
	useEffect(() => {
		const elem = promptArea.current;
		if (elem.value === promptText) {
			return;
		} else if (promptText.startsWith(elem.value)) {
			const oldHeight = elem.scrollHeight;
			const atBottom = elem.scrollTop + elem.clientHeight + 1 > oldHeight;
			const oldLen = elem.value.length;
			elem.setRangeText(promptText.slice(oldLen), oldLen, oldLen, 'preserve');
			const newHeight = elem.scrollHeight;
			if (atBottom && oldHeight !== newHeight) {
				elem.scrollTo({
					top: newHeight - elem.clientHeight,
					behavior: 'smooth',
				});
			}
		} else {
			elem.value = promptText;
		}
	}, [promptText]);

	useEffect(() => {
		if (cancel)
			return;
		const ac = new AbortController();
		const to = setTimeout(async () => {
			try {
				const { tokens } = await tokenize({
					endpoint,
					endpointAPI,
					content: ` ${promptText}`,
					signal: ac.signal,
				});
				setTokens(tokens.length + 1);
			} catch (e) {
				if (e.name !== 'AbortError')
					reportError(e);
			}
		}, 500);
		ac.signal.addEventListener('abort', () => clearTimeout(to));
		return () => ac.abort();
	}, [promptText, cancel]);

	useEffect(() => {
		function onKeyDown(e) {
			const { altKey, ctrlKey, shiftKey, key, defaultPrevented } = e;
			if (defaultPrevented)
				return;
			switch (`${altKey}:${ctrlKey}:${shiftKey}:${key}`) {
			case 'false:false:true:Enter':
			case 'false:true:false:Enter':
				predict();
				break;
			case 'false:false:false:Escape':
				cancel();
				break;
			default:
				return;
			}
			e.preventDefault();
		}

		window.addEventListener('keydown', onKeyDown);
		return () => window.removeEventListener('keydown', onKeyDown);
	}, [predict, cancel]);

	function onInput({ target }) {
		setPrompt(oldPrompt => {
			const start = [];
			const end = [];
			oldPrompt = [...oldPrompt];
			let newValue = target.value;

			while (oldPrompt.length) {
				const chunk = oldPrompt[0];
				if (!newValue.startsWith(chunk.content))
					break;
				oldPrompt.shift();
				start.push(chunk);
				newValue = newValue.slice(chunk.content.length);
			}

			while (oldPrompt.length) {
				const chunk = oldPrompt.at(-1);
				if (!newValue.endsWith(chunk.content))
					break;
				oldPrompt.pop();
				end.unshift(chunk);
				newValue = newValue.slice(0, -chunk.content.length);
			}

			return [
				...start,
				...(newValue ? [{ type: 'user', content: newValue }] : []),
				...end,
			];
		});
	}

	function onScroll({ target }) {
		promptOverlay.current.scrollTop = target.scrollTop;
		promptOverlay.current.scrollLeft = target.scrollLeft;
	}

	function onPromptMouseMove({ clientX, clientY }) {
		promptOverlay.current.style.pointerEvents = 'auto';
		const elem = document.elementFromPoint(clientX, clientY);
		const pc = elem?.closest?.('[data-promptchunk]');
		const probs = elem?.closest?.('#probs');
		promptOverlay.current.style.pointerEvents = 'none';
		if (probs)
			return;
		if (!pc) {
			setCurrentPromptChunk(undefined);
			return;
		}
		const rect = [...pc.getClientRects()].at(-1);
		const index = +pc.dataset.promptchunk;
		const top = rect.top;
		const left = rect.x + rect.width / 2;
		setCurrentPromptChunk(cur => {
			if (cur && cur.index === index && cur.top === top && cur.left === left)
				return cur;
			return { index, top, left };
		});
	}

	async function switchCompletion(i, tok) {
		if (cancel) {
			cancel?.();

			// llama.cpp server sometimes generates gibberish if we stop and
			// restart right away (???)
			await new Promise(res => setTimeout(res, 500));
		}

		const newPrompt = [
			...prompt.slice(0, i),
			{
				...prompt[i],
				content: tok,
			},
		];
		setPrompt(newPrompt);
		predict(joinPrompt(newPrompt));
	}

	function switchEndpointAPI(value) {
		var url = new URL(endpoint);
		switch (value) {
			case 0: // llama.cpp
				if (url.protocol != 'http' && url.protocol != 'https')
					url.protocol = "http";
				url.port = 8080;
				break;
			case 1: // oobabooga
				if (url.protocol != 'ws' && url.protocol != 'wss')
					url.protocol = "ws";
				url.port = 5005;
				break;
			case 2: // koboldcpp
				if (url.protocol != 'http' && url.protocol != 'https')
					url.protocol = "http";
				url.port = 5001;
				break;
		}
		setEndpoint(url.toString());
		setEndpointAPI(value);
	}

	function switchDarkMode(value, force) {
		if (value) {
			document.documentElement.classList.add('dark-mode');
		} else {
			document.documentElement.classList.remove('dark-mode');
		}
		if (!force)
			setDarkMode(value);
	}

	const probs = useMemo(() =>
		prompt[currentPromptChunk?.index]?.completion_probabilities?.[0]?.probs,
		[prompt, currentPromptChunk]);

	return html`
		<div id="prompt-container" onMouseMove=${onPromptMouseMove}>
			<textarea
				ref=${promptArea}
				readOnly=${!!cancel}
				id="prompt-area"
				onInput=${onInput}
				onScroll=${onScroll}/>
			<div ref=${promptOverlay} id="prompt-overlay">
				${prompt.map((chunk, i) => {
					const isCurrent = currentPromptChunk && currentPromptChunk.index === i;
					return html`
						<span
							key=${i}
							data-promptchunk=${i}
							className=${`${chunk.type === 'user' ? 'user' : 'machine'} ${isCurrent ? 'current' : ''}`}>
							${chunk.content + (i === prompt.length - 1 && chunk.content.endsWith('\n') ? '\u00a0' : '')}
						</span>`;
				})}
			</div>
		</div>
		${probs ? html`
			<div
				id="probs"
				style=${{
					'--probs-top': `${currentPromptChunk.top}px`,
					'--probs-left': `${currentPromptChunk.left}px`,
				}}>
				${probs.map((prob, i) =>
					html`<button key=${i} onClick=${() => switchCompletion(currentPromptChunk?.index, prob.tok_str)}>
						<div className="tok">${prob.tok_str}</div>
						<div className="prob">${(prob.prob * 100).toFixed(2)}%</div>
					</button>`)}
			</div>` : null}
		<div id="sidebar">
			<div className="sidebar-hbox">
				<${Checkbox} label="Dark Mode"
					value=${darkMode} onValueChange=${() => switchDarkMode(!darkMode, false)}/>
				<button onClick=${resetPersistence}>Reset</button>
			</div>
			<${InputBox} label="Server"
				value=${endpoint} onValueChange=${setEndpoint}/>
			<${SelectBox}
				label="API"
				value=${endpointAPI}
				onValueChange=${switchEndpointAPI}
				options=${[
					{ name: 'llama.cpp', value: 0 },
					{ name: 'oobabooga', value: 1 },
					{ name: 'koboldcpp', value: 2 },
				]}/>
			<${InputBox} label="Seed" type="number"
				value=${seed} onValueChange=${setSeed}/>
			<${InputBox} label="Temperature" type="number" step="0.01"
				value=${temperature} onValueChange=${setTemperature}/>
			<div className="sidebar-hbox">
				<${InputBox} label="Repeat penalty" type="number" step="0.01"
					value=${repeatPenalty} onValueChange=${setRepeatPenalty}/>
				<${InputBox} label="Repeat last n" type="number" step="1"
					value=${repeatLastN} onValueChange=${setRepeatLastN}/>
			</div>
			<${Checkbox} label="Penalize NL"
				value=${penalizeNl} onValueChange=${setPenalizeNl}/>
			<div className="sidebar-hbox">
				<${InputBox} label="Presence penalty" type="number" step="0.01"
					value=${presencePenalty} onValueChange=${setPresencePenalty}/>
				<${InputBox} label="Frequency penalty" type="number" step="1"
					value=${frequencyPenalty} onValueChange=${setFrequencyPenalty}/>
			</div>
			${temperature <= 0 ? null : html`
				<${SelectBox}
					label="Mirostat"
					value=${mirostat}
					onValueChange=${setMirostat}
					options=${[
						{ name: 'Off', value: 0 },
						{ name: 'Mirostat', value: 1 },
						{ name: 'Mirostat 2.0', value: 2 },
					]}/>
				${mirostat ? html`
					<div className="sidebar-hbox">
						<${InputBox} label="Mirostat τ" type="number" step="0.01"
							value=${mirostatTau} onValueChange=${setMirostatTau}/>
						<${InputBox} label="Mirostat η" type="number" step="0.01"
							value=${mirostatEta} onValueChange=${setMirostatEta}/>
					</div>
				` : html`
					<div className="sidebar-hbox">
						<${InputBox} label="Top K" type="number" step="1"
							value=${topK} onValueChange=${setTopK}/>
						<${InputBox} label="Top P" type="number" step="1"
							value=${topP} onValueChange=${setTopP}/>
					</div>
					<div className="sidebar-hbox">
						<${InputBox} label="Typical p" type="number" step="0.01"
							value=${typicalP} onValueChange=${setTypicalP}/>
						<${InputBox} label="Tail Free Sampling z" type="number" step="0.01"
							value=${tfsZ} onValueChange=${setTfsZ}/>
					</div>
				`}
			`}
			<${Checkbox} label="Ignore <eos>"
				value=${ignoreEos} onValueChange=${setIgnoreEos}/>
			${!!tokens && html`
				<${InputBox} label="Tokens" value=${tokens} readOnly/>`}
			<div className="buttons">
				<button
					className=${cancel ? 'completing' : ''}
					disabled=${!!cancel}
					onClick=${() => predict()}>
					Predict
				</button>
				<button disabled=${!cancel} onClick=${cancel}>Cancel</button>
			</div>
		</div>`;
}

createRoot(document.body).render(html`<${App}/>`);

</script>
